# -*- coding: utf-8 -*-
"""
@author: ClÃ©ment Hardy, PhD.
# -*- coding: utf-8 -*-

This is a Python script that contains the functions
used by the main script (MHS-CBAU_MainScript.py) for
the MHS-CBAU approach (see https://github.com/Klemet/MHS-CBAU).

WARNING : Make sure this script is located in the same folder
as MHS-CBAU_MainScript.py; if not, MHS-CBAU_MainScript.py will not work !

The functions are organised into sections to find them more easily :
    
- Generalist helper functions (small functions to help in other functions)
- Functions to read inputs
- Functions to prepare objects
- Functions to make the management decisions
- Functions for random choices
- Functions to write files
    
"""

#%% IMPORTING MODULES

import os, csv, json, re
import pandas as pd
import numpy as np
from tqdm import tqdm
from collections import Counter
import random
import rasterio

# Removes some rasterio warnings about missing Georeferencing, which is normal
# since all output rasters of LANDIS-II are missing georeferencing.
import warnings
warnings.filterwarnings("ignore", category=rasterio.errors.NotGeoreferencedWarning)

#%% GENERALIST HELPER FUNCTIONS
# Small functions used for simple tasks that can be used in several
# other functions.

def getRasterData(path):
    """
    Used to read the data of a raster and put it inside a numpy array.
    WARNING : Made for single-band rasters. For multi-bands rasters, the
    function will retrieve the first band. 

    Parameters
    ----------
    path : STRING
        Path to the raster file.

    Returns
    -------
    A numpy array containing data from the first band of the raster.

    """
    with rasterio.open(path) as raster:
        rasterData = raster.read(1)
    return np.array(rasterData)


def readJSONDictionnary(path):
    """
    Reads a Python Dictionnary from a JSON file. Used to load the dictionnaries
    containing biomass ratios values (see /scriptsToGenerateInputs/4.MerchantableBiomassDictionnary)
    and the wood density values (see scriptsToGenerateInputs/5.WoodDensityBiomassDictionnary)
    
    Returns a Python dictionnary.
    """
    try:
        with open(path, 'r') as f:
            data_dict = json.load(f)
            # Now data_dict is a Python dictionary
            # print(data_dict)
    except FileNotFoundError:
        print(f"    MHS-CBAU :  Error: The file '{path}' was not found.")
    except json.JSONDecodeError:
        print(f"    MHS-CBAU :  Error: Could not decode JSON from the file '{path}'. Ensure it's valid JSON.")
    except Exception as e:
        print(f"    MHS-CBAU :  An unexpected error occurred: {e}")
    return data_dict


def splitLineAndRemoveTabsAndSpaces(lineString):
    """
    Used to parse certain lines of the biomass harvest txt parameter file
    (see harvestParameterFileParser).
    """
    lineStringList = lineString.replace('\t', ' ').replace("\n", "").replace(">>", "").split(" ")
    while "" in lineStringList:
        lineStringList.remove("")
    return(lineStringList)


#%% FUNCTIONS TO READ INPUTS OR PARAMETER FILES
# Functions used at the beginning of the main script to read
# the input files needed.

def biomassHarvestParameterFileParser(pathToBiomassHarvestParameterFile,
                                      speciesList):
    """
    Parses the biomass harvest parameter file at the given path.
    Returns a dictionnary with the needed parameters.
    
    WARNING : This function is complex so as to adapt to the different formats
    and keyword the harvest parameter file can take.
    
    WARNING : The file being parsed should not be the template, but the file
    already prepared via prepareBiomassHarvestParameterFile() beforehand, so that
    it contains the correct instructions for the prescriptions.
    
    WARNING : To read the harvest file properly, make sure to :
    - Not use relative number of cohorts harvested for a given species, like
      "1/2" or "1/3". Since this script is made to be used with biomass harvest,
      use things like "11-999(50%)" to harvest half of the biomass of each cohort.
    - Make sure the biomass percentages are not separated from their respective
      age class, meaning write "11-999(50%)" rather than "11-999 (50%)"

    Parameters
    ----------
    pathToBiomassHarvestParameterFile : STRING
        Path to the biomass harvest parameter file, having been prepared already
        by the function prepareBiomassHarvestParameterFile().
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are.
    speciesList : LIST
        Contains the list of the species used for the simulation. Generated by
        readSpeciesList().

    Raises
    ------
    ValueError
        In case a relative number of cohorts, like 1/2 or 1/3 is used (see warning
        above).

    Returns
    -------
    A dictionnary containing the parameters of the file. The format is
    dict[Name of prescription][Name of parameter]. The object registered for a
    given parameter can be a value or a list of value or a string, depending on
    the parameter.

    """
    print("    MHS-CBAU : Reading harvest parameter file...")
    
    prescriptionParameters = dict()
    
    with open(pathToBiomassHarvestParameterFile, 'r') as file:
        prescriptionSelected = "none"
        prescriptionID = 1 # We start at 1 because the ID is for the raster;
        # 0 = not forest, 1 = forest not harvested, and then it's the prescriptions.
        for line in file:
            # print(line)
            # if ">>-------------" in line:
            #     prescriptionSelected = "none"
            # If line is a comment, we skip !
            if ">>---------" in line or ">> ---------" in line or ">> AUTRES PRESCRIPTIONS QUE COUPES TOTALES" in line:
                continue
            # We start by recording the lines if we're reading a prescription
            if prescriptionSelected != "none" and "Prescription " not in line:
                prescriptionParameters[prescriptionSelected]["FullString"].append(line)

            # We get the timestep used by the extension
            if "Timestep" in line and ">>" not in line:
                timestepLength = int(splitLineAndRemoveTabsAndSpaces(line)[1])
            # If we find a new prescription, we initialize everything needed
            if "Prescription " in line and ">>" not in line:
                prescriptionSelected = line[len("Prescription "):-1] #-1 removes the \n character at the end of each line
                if prescriptionSelected not in prescriptionParameters:
                    prescriptionParameters[prescriptionSelected] = dict()
                    prescriptionParameters[prescriptionSelected]["Planting"] = "none"
                    prescriptionParameters[prescriptionSelected]["RepeatMode"] = "none"
                    prescriptionParameters[prescriptionSelected]["MaximumStandAge"] = 999
                    prescriptionParameters[prescriptionSelected]["MinimumStandAge"] = 0
                    prescriptionParameters[prescriptionSelected]["FullString"] = [line] # We keep all the lines of the prescription to be able to copy it to make different plantings
                    prescriptionID += 1
                    prescriptionParameters[prescriptionSelected]["PrescriptionID"] = prescriptionID
                singleRepeat = False
            
            # Else, we register the parameters of the prescription
            elif "MaximumAge" in line and ">>" not in line:
                maximumAge = splitLineAndRemoveTabsAndSpaces(line)[1]
                prescriptionParameters[prescriptionSelected]["MaximumStandAge"] = int(maximumAge)
            elif "MinimumAge" in line and ">>" not in line:
                minimumAge = splitLineAndRemoveTabsAndSpaces(line)[1]
                prescriptionParameters[prescriptionSelected]["MinimumStandAge"] = int(minimumAge)
            elif "SiteSelection" in line and ">>" not in line and "Complete" not in line:
                # The line contains 2 words + the two numerical values we want
                # We remove everything we don't need to get the two values
                splittedLine = splitLineAndRemoveTabsAndSpaces(line)
                # print(splittedLine)
                prescriptionParameters[prescriptionSelected]["HarvestPropagation"] = [float(splittedLine[2]), float(splittedLine[3])]
            elif "CohortsRemoved" in line and not singleRepeat and ">>" not in line:
                prescriptionParameters[prescriptionSelected]["CohortRemoved"] = dict()
            elif ">> PlantingMagicHarvest" in line:
                plantingString = splitLineAndRemoveTabsAndSpaces(line)[1]
                prescriptionParameters[prescriptionSelected]["Planting"] = plantingString
            elif ">> MagicHarvest_MinMaxAgeStands" in line:
                minAge = splitLineAndRemoveTabsAndSpaces(line)[1]
                maxAge = splitLineAndRemoveTabsAndSpaces(line)[2]
                prescriptionParameters[prescriptionSelected]["MinimumStandAge"] = minAge
                prescriptionParameters[prescriptionSelected]["MaximumStandAge"] = maxAge
            elif ">> Second_Pass" in line:
                secondPassPrescription = splitLineAndRemoveTabsAndSpaces(line)[1]
                prescriptionParameters[prescriptionSelected]["SecondPassPrescription"] = secondPassPrescription
            elif "SingleRepeat" in line and ">>" not in line:
                singleRepeat = True
                prescriptionParameters[prescriptionSelected]["CohortRemoved"]["SingleRepeat"] = dict()
                prescriptionParameters[prescriptionSelected]["RepeatMode"] = "SingleRepeat"
                repeatFrenquency = splitLineAndRemoveTabsAndSpaces(line)[1]
                prescriptionParameters[prescriptionSelected]["RepeatFrequency"] = int(repeatFrenquency)
            elif "MultipleRepeat" in line and ">>" not in line:
                prescriptionParameters[prescriptionSelected]["RepeatMode"] = "MultipleRepeat"
                repeatFrenquency = splitLineAndRemoveTabsAndSpaces(line)[1]
                prescriptionParameters[prescriptionSelected]["RepeatFrequency"] = int(repeatFrenquency)
                
            # If we get to the part about the cohort removed, it's a bit more tricky
            # to register
            # In particular, we will register the cohort removed in the case of a
            # second pass (via SingleRepeat) in a different nested dictionnary
            for species in speciesList:
                if species in line and "Prescription " not in line and "Plant" not in line and ">>" not in line:
                    if not singleRepeat:
                        prescriptionParameters[prescriptionSelected]["CohortRemoved"][species] = dict()
                    else:
                        prescriptionParameters[prescriptionSelected]["CohortRemoved"]["SingleRepeat"][species] = dict()
                    # 3 cases :
                    # just ages (11-999)
                    # "All" keyword
                    # ages categories with biomass percent (11-999(90%))
                    # print(line)
                    if "/" in line: # Just in case their are relative cohort numbers in the file
                        raise ValueError("Do not use relative number of cohort harvested for a given species, like \"1/2\" or \"1/3\". Since this script is made to be used with biomass harvest, use things like \"11-999(50%)\" to harvest half of the biomass of each cohort.")
                    elif "All" in line or "all" in line and ">>" not in line:
                        if not singleRepeat:
                            prescriptionParameters[prescriptionSelected]["CohortRemoved"][species] = "All"
                        else:
                            prescriptionParameters[prescriptionSelected]["CohortRemoved"]["SingleRepeat"][species] = "All"
                    else: # If not all, we have to break appart the age categories
                        if not singleRepeat:
                            prescriptionParameters[prescriptionSelected]["CohortRemoved"][species] = list()
                        else:
                            prescriptionParameters[prescriptionSelected]["CohortRemoved"]["SingleRepeat"][species] = list()
                        splittedLine = splitLineAndRemoveTabsAndSpaces(line)
                        # print(splittedLine)
                        for ageCategory in splittedLine[1:]:
                            if "%" not in ageCategory:
                                splitAgeCategory = ageCategory.split("-")
                                # We add a list describing 1) min age of category 2) max age of category 3) % of biomass harvested
                                if not singleRepeat:
                                    prescriptionParameters[prescriptionSelected]["CohortRemoved"][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), 100])
                                else:
                                    prescriptionParameters[prescriptionSelected]["CohortRemoved"]["SingleRepeat"][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), 100])
                            else:
                                splitAgeCategory = ageCategory.replace("(", "-").replace("%)", "").split("-")
                                if not singleRepeat:
                                    prescriptionParameters[prescriptionSelected]["CohortRemoved"][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), int(splitAgeCategory[2])])
                                else:
                                    prescriptionParameters[prescriptionSelected]["CohortRemoved"]["SingleRepeat"][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), int(splitAgeCategory[2])])
                        
            if "HarvestImplementations" in line and ">>" not in line:
                break
                
    return(prescriptionParameters, timestepLength)


def determineForestTypesOfStands(standCompositionDict,
                                 standCoordinatesDict,
                                 speciesShadeToleranceDict,
                                 disableTQDM = False):
    """
    Classify forest stands into four categories based on
    age structure (even-aged or uneven-aged) and shade tolerance (tolerant or intolerant).
    
    The rules are as follow :
        
    - if 75% or more of the total biomass of a stand is lumped in a group of
    age cohorts that are 20 years appart at the maximum, then we'll consider it
    even-aged. If not, we'll consider it uneven-aged. 
    - if 50% or more of the stand is made of shade intolerant species,
    we'll give it the shade intolerant status. If not, it will be indicated
    as shade tolerant.

    Parameters
    ----------
    standCompositionDict : Dictionnary
        Created by readVegetationInLandscape(). Contains informations about
        the age cohorts present in the pixels of a stand.
    standCoordinatesDict : Dictionnary
        Created by readingStandsCoordinates(). Contains the list of pixels
        coordinates for all of the pixels inside a given stand ID.
    speciesShadeToleranceDict : Dictionnary
        Created with readJSONDictionnary() from the json file containing information
        about the shade tolerance status of tree species in Canada.
    disableTQDM : Boolean, optional
        Used to deactivate the TQDM progress bar. The default is False.

    Returns
    -------
    A dictionnary giving the category of each stand by stand ID.

    """
    forestTypesStandsDict = dict()

    for standID in tqdm(standCompositionDict, desc="Classifying stands", disable=disableTQDM):
        # Calculate total biomass and collect age-biomass pairs
        total_biomass = 0
        age_biomass_list = []
        species_biomass = {}

        for species, age_cohorts in standCompositionDict[standID].items():
            for age, biomass in age_cohorts.items():
                total_biomass += biomass
                age_biomass_list.append((age, biomass))
                species_biomass[species] = species_biomass.get(species, 0) + biomass

        # Determine if even-aged or uneven-aged
        is_even_aged = False
        age_biomass_list.sort(key=lambda x: x[0])  # Sort by age

        for i in range(len(age_biomass_list)):
            min_age = age_biomass_list[i][0]
            max_age = min_age + 20
            biomass_in_range = sum(biomass for age, biomass in age_biomass_list 
                                   if min_age <= age <= max_age)

            if biomass_in_range >= 0.75 * total_biomass:
                is_even_aged = True
                break

        # Determine if shade tolerant or intolerant
        intolerant_biomass = 0

        for species, biomass in species_biomass.items():
            if species in speciesShadeToleranceDict:
                tolerance = speciesShadeToleranceDict[species]["shade_tolerance"]["shade_tolerance"]
                if tolerance == "intolerant":
                    intolerant_biomass += biomass

        is_shade_intolerant = (intolerant_biomass >= 0.5 * total_biomass)

        # Classify the stand
        if is_even_aged and is_shade_intolerant:
            forestTypesStandsDict[standID] = "Even-aged and shade intolerant"
        elif is_even_aged and not is_shade_intolerant:
            forestTypesStandsDict[standID] = "Even-aged and shade tolerant"
        elif not is_even_aged and is_shade_intolerant:
            forestTypesStandsDict[standID] = "Uneven-aged and shade intolerant"
        else:
            forestTypesStandsDict[standID] = "Uneven-aged and shade tolerant"

    return forestTypesStandsDict


def getStandAges(standCoordinatesDict, standCompositionDict):
    """
    Calculate the biomass-weighted average age of all cohorts in a forest stand.

    Parameters
    ----------
    standCoordinatesDict : DICT
        Contains the coordinates of all pixels in each stand. Generated by readingStandsCoordinates().
    standCompositionDict : DICT
        Contains the composition of each stand. Generated by readVegetationInLandscape().
        
    Returns:
        Dictionnary that associate the age to everystand
    """
    
    standAgeDict = dict()
    
    for standID in standCoordinatesDict:
        if standID not in standCompositionDict:
            standAgeDict[standID] = 0.0

        else:
            stand_data = standCompositionDict[standID]
        
            total_weighted_age = 0.0
            total_biomass = 0.0
        
            # Iterate through all species in the stand
            for species, cohorts in stand_data.items():
                # Iterate through all cohorts of this species
                for cohort_age, biomass in cohorts.items():
                    total_weighted_age += cohort_age * biomass
                    total_biomass += biomass
        
            # Avoid division by zero
            if total_biomass == 0:
                return 0.0
            else:
                standAgeDict[standID] = total_weighted_age / total_biomass

    return standAgeDict


def loadDecisionMatrix(csv_file_path):
    """
    This function is made to load the decision matrix (probabilityMatrixCutsVersusStandType.csv
    which is in /otherInputs) inside a dictionnary.

    Parameters
    ----------
    csv_file_path : string
        Path to probabilityMatrixCutsVersusStandType.csv.
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are.

    Returns
    -------
    dictProbabilitiesForestCutsPerForestType : dictionnary
        The first key of the dictionnary
       is the stand type (e.g. "Even-aged and shade tolerant"), the second is the
       forest cut type (e.g. clearcutting, etc.); it then returns the probability
       associated with the stand and forest cut type..

    """
    dictProbabilitiesForestCutsPerForestType = {}

    with open(csv_file_path, 'r') as file:
        reader = csv.DictReader(file)

        # Get column names (excluding the first column)
        columns = reader.fieldnames[1:]

        # Initialize the nested dictionary structure
        for column in columns:
            dictProbabilitiesForestCutsPerForestType[column] = {}

        # Populate the dictionary
        for row in reader:
            treatment = row['Commercial treatment']
            for column in columns:
                dictProbabilitiesForestCutsPerForestType[column][treatment] = float(row[column])

    return dictProbabilitiesForestCutsPerForestType


def loadForestCutSizesProbabilities(filepath: str):
    """
    Loads forest cut type distributions from cut_size_distributions.json, which is
    a JSON file containing forest cut types (e.g., Clearcut, Shelterwood) 
    with their associated bin upper bounds and probability distributions.

    Parameters
    ----------
    filepath : str
        Path to the JSON file containing forest cut distribution data.
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are.

    Returns
    -------
    Dict[str, Dict[str, List[float]]]
        Nested dictionary where:
        - First level keys are forest cut types (e.g., "Clearcut")
        - Second level keys are "bin_upper_bounds" and "probabilities_percent"
        - Values are lists of floats representing the bin bounds and probabilities
    """
    with open(filepath, 'r') as f:
        data = json.load(f)

    dictForestCutSizesDistribution = {}
    for cut_type, cut_data in data.items():
        dictForestCutSizesDistribution[cut_type] = {
            'bin_upper_bounds': cut_data['bin_upper_bounds'],
            'probabilities_percent': cut_data['probabilities_percent']
        }

    return dictForestCutSizesDistribution


def readSpeciesList(landisCoreSpeciesParametersFile):
    """
    Reads the list of species simulated in your simulated from the core species
    parameter files of LANDIS-II (the one containing information about
    longevity, sexual maturity, etc.).
    
    The list is used in other functions.

    Parameters
    ----------
    landisCoreSpeciesParametersFile : STRING
        Path to the core species parameter file used in LANDIS-II. This is the
        file that contains the main parameters for the species you are simulating
        (e.g. longevity, sexual maturity, etc.). The list of species will be read
        from this file, so as to write harvest instructions for each species (which
        is sadly necessary due to the syntax used for the parameters of Biomass Harvest).
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are. This is because
        the working directory used by Magic Harvest will be the one used by LANDIS-II,
        which is the one where the scenario file is located. As such, if you scenario
        file is located in /SimulationFolder/scenario.txt, and if the core species
        parameter file is in /SimulationFolder/inputs/succession/species.txt, then
        the path you should put must be ./inputs/succession/species.txt.

    Returns
    -------
    A list of species names.

    """
    
    speciesList = []
    with open(landisCoreSpeciesParametersFile, 'r') as f:
        for line in f:
            line = line.strip()
            # Skip empty lines, comments, and LandisData line
            if not line or line.startswith('>>') or line.startswith('LandisData'):
                continue
            # Extract first column (species name)
            species_name = line.split()[0]
            speciesList.append(species_name)
            
    return speciesList


def readRepeatedPrescriptions(folderOfRepeatedPrescriptionsFile, timestep):
    """
    Loads the data of the repeated prescriptions from a JSON file.

    Parameters
    ----------
    folderOfRepeatedPrescriptionsFile : STRING
        Folder where the file should be created. It will be named dynamically.

    Returns
    -------
    repeatPrescriptionsDict : DICT
        Dictionary containing information about the repeated prescriptions.
        The format of the dictionary is :
            repeatPrescriptionsDict[prescription][groupOfStands] = Repetitions
        Repetitions are years (since beginning of simulation) when the repetition
        should happen. Can be a single value or a list of values.

    """

    # Reading JSON file for repeated prescriptions
    repeatPrescriptionPath = folderOfRepeatedPrescriptionsFile + "/repeatedPrescriptions_" + str(timestep) + ".json"
    if os.path.exists(repeatPrescriptionPath):
        with open(repeatPrescriptionPath, "r") as file:
            repeatPrescriptionsDict = json.load(file)
        # JSON tends to put the stands ID as string. We put them back as int.
        for prescription in repeatPrescriptionsDict.keys():
            repeatPrescriptionsDict[prescription] = {int(k): v for k, v in repeatPrescriptionsDict[prescription].items()}
    else:
        repeatPrescriptionsDict = "noRepeatsForNow"
    
    return repeatPrescriptionsDict


def readingStandManagementUnit(standMapPath, managementUnitsMapPath, disableTQDM = True):
    """
    Assign a management unit (UA) code to each stand. Can be used to know
    what stands are in a management area, or to modify the script in order
    to do different forms of zoning (e.g. TRIAD).
    
    Is also used to read the ecozones in which each stand is, used to retrieve
    the right merchantable biomass coefficients.

    Parameters
    ----------
    standMapPath : STRING
        Path to the raster map containing the position of the stands.
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are.
    managementUnitsMapPath : STRING
        Path to the map containing the position of the management units.
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are.
        WARNING : A stand must have all of its pixel in a single management unit.
        If it doesn't, then the management unit ID that will be chosen will be the one
        where most of the pixels of the stand are.
    disableTQDM : BOOLEAN
        To disable the progress bar of the function. Only useful for debugging.

    Returns
    -------
    A dictionnary associated a stand ID to a management area ID.

    """
    
    print("    MHS-CBAU : Reading stands management units (used for volume conversion or protected areas)...")
    
    standData = getRasterData(standMapPath)
    uniqueAllStandsID = np.unique(standData).tolist()
    # id 0 for stands = no forests
    uniqueAllStandsID.remove(0)
    managementUnitsMap = getRasterData(managementUnitsMapPath)
    managementUnitDict = dict()
    # Little trick to use the power of numpy below
    # We make an array with the pixels we want the value of, and another
    # with the values
    pixelCoordinates = np.where(standData != 0)
    standIDinPixelCoordinates = standData[pixelCoordinates]
    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):
        managementUnitDict[standID] = list()
    # We get the data for the harvestable pixels
    managementUnitInPixel = managementUnitsMap[pixelCoordinates]
    # We fill the dictionnary with the different values of max cohort age for each
    # pixels in a stand
    for i in tqdm(range(0, len(pixelCoordinates[0])), disable = disableTQDM):
        managementUnitDict[standIDinPixelCoordinates[i]].append(managementUnitInPixel[i])
    # We make a dictionnary containing the most common management area ID in the stand.
    standManagementUnitDict = dict()
    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):
        standManagementUnitDict[standID] = Counter(managementUnitDict[standID]).most_common(1)[0][0]
    return(standManagementUnitDict)


def readingStandsCoordinates(standMapPath, disableTQDM = True):
    """
    Reads the stands map to get the coordinates of each pixel in a stand.
    Returns a dictionnary giving the coordinates for each pixel for a given
    stand ID. Locations are in (row, column) tuple format, as necessary to
    access a value in a numpy array made from a raster by GDAL

    Parameters
    ----------
    standMapPath : STRING
        Path to the raster map containing the position of the stands.
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are.
    disableTQDM : TYPE
        To disable the progress bar of the function. Only useful for debugging.

    Returns
    -------
    A dictionnary associating every stand ID to a list of pixel coordinates.

    """
    print("    MHS-CBAU : Reading stands coordinates...")
    standData = getRasterData(standMapPath)
    standCoordinatesDict = dict()
    uniqueAllStandsID = np.unique(standData).tolist()
    # id 0 for stands = no forests
    uniqueAllStandsID.remove(0)
    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):
        # print(standID)
        standCoordinatesDict[standID] = list()
    for x in tqdm(range(standData.shape[0]), disable = disableTQDM):
        for y in range(standData.shape[1]):
            standID = standData[(x, y)]
            if standID != 0:
                standCoordinatesDict[standID].append((x, y))
    return(standCoordinatesDict)


def readingStandsNeighbors(standMapPath,
                           standCoordinatesDict,
                           disableTQDM = True):
    """
    Reads the neighbors of each stand by looking at the surrounding
    pixels of those of the stands, and getting their stand ID. 

    Parameters
    ----------
    standMapPath : STRING
        Path to the raster map containing the position of the stands.
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are.
    standCoordinatesDict : DICT
        Dictionnary of stand coordinates created by readingStandsCoordinates().
    disableTQDM : TYPE, optional
        To disable the progress bar of the function. Only useful for debugging.

    Returns
    -------
    Returns a dictionnary
    with the list of neighbors's stand ID for each stand.

    """
    
    standData = getRasterData(standMapPath)
    print("    MHS-CBAU : Reading stand neighbors...")
    # Making a dictionnary which tells what stand is a neighbor of which one.
    # We only need it for harvestable stands, since this is for the propagation
    # of cuts.
    standNeighboursDict = dict()
    minXRange = range(standData.shape[0])[0]
    maxXRange = range(standData.shape[0])[-1]
    minYRange = range(standData.shape[1])[0]
    maxYRange = range(standData.shape[1])[-1]
    for standID in tqdm(standCoordinatesDict.keys(), disable = disableTQDM):
        listOfNeighbouringStands = list()
        for pixel in standCoordinatesDict[standID]:
            listOfStandsAroundPixel = list()
            # We look at the 8 neighbors of the pixel, if not out of range,
            # to try to detect another stand number
            # First, we prepare the ranges around which we'll loop, and make sure
            # we're not out of bounds
            xMinus1 = max(pixel[0] - 1, minXRange)
            xPlus1 = min(pixel[0] + 1, maxXRange)
            yMinus1 = max(pixel[1] - 1, minYRange)
            yPlus1 = min(pixel[1] + 1, maxYRange)
            # Now, we loop to find values
            for x in [xMinus1, pixel[0], xPlus1]:
                for y in [yMinus1, pixel[1], yPlus1]:
                    listOfStandsAroundPixel.append(standData[(x, y)])
            uniqueNeighbouringStands = set(listOfStandsAroundPixel)
            # We remove mentions of the present stand and of the value 0
            uniqueNeighbouringStands.discard(standID)
            uniqueNeighbouringStands.discard(0)
            listOfNeighbouringStands.extend(list(uniqueNeighbouringStands))
        # We add the resulting unique standID that we found as neighbors to this stand
        standNeighboursDict[standID] = set(listOfNeighbouringStands)
    return(standNeighboursDict)


def readVegetationInLandscape(communityCsvPath,
                            communityMapPath,
                            standCoordinatesDict,
                            disableTQDM = True):
    """
    Reads the communities csv and raster map made by Output Biomass Community
    to make a dictionnary containing the species and age cohorts for each
    species and biomass for these cohorts for all of the pixels of a stand.
    
    WARNING : the dictionnary doesn't contain entries for stands that have
    no cohorts/no biomass, and no entries for species that are not in a stand
    or cohorts that do not exist for a species. This saves on a lot of space,
    but one gots to check if the entries are there when using the dictionnary.

    Parameters
    ----------
    communityCsvPath : STRING
        Relative Path to the CSV file containing the output of the extension
        biomass community output from the previous timestep. 
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are.
        The path is most likely "./community-input-file-" + str(timestep- timestepLength) + ".csv".
    communityMapPath : STRING
        Relative Path to the .img raster file containing the output of the extension
        biomass community output from the previous timestep. 
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are.
        The path is most likely "./output-community-" + str(timestep- timestepLength) + ".img".
    standCoordinatesDict : DICT
        Dictionnary containing the coordinates of stands, created by readingStandsCoordinates().
    disableTQDM : BOOLEAN
        Useful for debugging purposes only. Shows the progression of the reading. Should be fast.

    Returns
    -------
    A dictionnary of the following format :
    standCommunitiesDict[standID][SpeciesName][CohortAge] = Cohort Biomass in the stand (in Metric tons).
    
    WARNING : There can be several cohorts of the same species and same age but in different
    pixels of the stands. If that's the case, their biomass is just added together (which is OK, since
    we express the biomass in its absolute value of metric tons, instead of a surface value like g/m2).
    A such, it's a bit like the whole stand is treated like one big pixel.
    """

    # communityCsvPath = "./community-input-file-" + str(timestep) + ".csv"
    # communityMapPath = "./output-community-" + str(timestep) + ".img"
    print("    MHS-CBAU : Reading communities csv and map...")
    # We only need the mapcode column from the csv from now.
    communityCsv = pd.read_csv(communityCsvPath, usecols=['MapCode'])
    communityMapCodeData = getRasterData(communityMapPath)

    # We make the dictionnary of the amount of times a stand is associated
    # to a mapcode
    print("    MHS-CBAU : Creating mapcode community dictionnary...")
    dictMapCodeStands = dict()
    for uniqueMapCode in communityCsv["MapCode"].unique():
        dictMapCodeStands[uniqueMapCode] = dict()
        
    for standID in standCoordinatesDict.keys():
        for pixel in standCoordinatesDict[standID]:
            mapcode = communityMapCodeData[pixel]
            # If the mapcode is not already in the dictionnary, it was not in
            # the CSV; and if it's not in the CSV, it's because it's a mapcode
            # associated to no cohorts at all(total biomass of 0)
            if mapcode in dictMapCodeStands:
                if standID not in dictMapCodeStands[mapcode]:
                    dictMapCodeStands[mapcode][standID] = 1
                else:
                    dictMapCodeStands[mapcode][standID] += 1
    
    # Now, we can read the CSV file and fill in a second dictionnary with the
    # information for each stand
    # To lighten it, we won't put stands that have no biomass
    # (IMPORTANT FOR OTHER FUNCTIONS : have to check if stand is in dictionnary)
    print("    MHS-CBAU : Creating stand community dictionnary...")
    
    standCommunitiesDict = dict()
    with open(communityCsvPath, 'r') as file:
        reader = csv.reader(file)
        headers = next(reader)  # Read the header row
        for row in tqdm(reader, total=len(communityCsv["MapCode"]), disable = disableTQDM):
            # 0 is mapcode; 1 is species; 2 is cohort; 3 is biomass.
            for standID in dictMapCodeStands[int(row[0])]:
                if standID not in standCommunitiesDict:
                    standCommunitiesDict[standID] = dict()
                    standCommunitiesDict[standID][row[1]] = dict()
                    standCommunitiesDict[standID][row[1]][int(row[2])] = 0
                # If species not indicated for this stand, we put it
                elif row[1] not in standCommunitiesDict[standID]:
                    standCommunitiesDict[standID][row[1]] = dict()
                    standCommunitiesDict[standID][row[1]][int(row[2])] = 0
                # If age cohort not indicated for this stand/species, we put it
                elif int(row[2]) not in standCommunitiesDict[standID][row[1]]:
                    standCommunitiesDict[standID][row[1]][int(row[2])] = 0
                # Finally, we enter the biomass for the stand/species/cohort
                # If the stand has multiple pixel with this mapcode, we multiply
                # the biomass with the number of pixels
                # WARNING : Need to transform biomass from g/m2 to Mg/ha by dividing by 100
                standCommunitiesDict[standID][row[1]][int(row[2])] += (int(row[3])/100)*dictMapCodeStands[int(row[0])][standID]
        
    return(standCommunitiesDict)


#%% FUNCTIONS TO PREPARE OBJECTS BEFORE MANAGEMENT DECISIONS
# Functions used to prepare several objects that are used afterwards
# during the part of the script that will make the management decisions

def creatingWoodTargetCounterDict(woodVolumeTargets):
    """
    Initializes a dictionnary that will allow us to count the harvested wood
    volume for each of our wood volume target.

    Parameters
    ----------
    harvestTargetsDict : DICT
        Contains our wood volume target. Loaded by readJSONDictionnary().

    Returns
    -------
    volumeTargetCounterDict : DICT
        Same as harvestTargetsDict, but every entry is at 0.

    """
    
    volumeTargetCounterDict = dict()
    for target in woodVolumeTargets:
        volumeTargetCounterDict[target] = 0
    return volumeTargetCounterDict


def creatingStandHarvestTracker(standCoordinatesDict):
    """
    Creates a simple dictionnary that allow us to track if a stand has already
    been choosen for harvesting/for a prescription this timestep.

    Parameters
    ----------
    standCoordinatesDict : DICT
        Contains the coordinates of every pixels in each stand.
        Created by readingStandsCoordinates().
        
    Returns
    -------
    standIsAlreadyHarvestedDict, a dict where every stand ID has true or false.

    """
    
    standIsAlreadyHarvestedDict = dict()
    for standID in standCoordinatesDict.keys():
        standIsAlreadyHarvestedDict[standID] = False
    return(standIsAlreadyHarvestedDict)


def createStandRankingDataFrame(standCoordinatesDict, standCompositionDict,
                                forestTypesStandsDict, standManagementUnitDict, standAgeDict,
                                woodVolumeTargets, speciesTargetsDict):
    """
    Generate the dataframe that will allow us to rank stands to select them.
    The dataframe contains one row per stand, and different columns that indicate
    their attributes : Their total biomass, their biomass for each of the volume targets
    defined in harvestTargetsDict, their age, their type.

    Parameters
    ----------
    standCoordinatesDict : DICT
        Created by readingStandsCoordinates(). Contains the list of pixels
        coordinates for all of the pixels inside a given stand ID.
    standCompositionDict : DICT
        Created by readVegetationInLandscape(). Contains informations about
        the age cohorts present in the pixels of a stand.
    forestTypesStandsDict : DICT
        Created by determineForestTypesOfStands(). Contains the type of the
        forests of the stand (even/uneven-aged and shade tolerant/intolerant).
    standManagementUnitDict : DICT
        Created by readingStandManagementUnit(). Contains the code of the
        management unit in which the stand is. Useful to identify the stands
        in protected areas, or when doing zoning or other.
    standAgeDict : DICT
        Created by readingStandsAges(). Contains the age of the stands
        (average of the age of the oldest cohorts in each pixels of the stand).
    woodVolumeTargets : DICT
        Created by prepareVolumeHarvestTargetForTimestep(). Contains the volumes targets
        of harvest for the timestep.
    speciesTargetsDict : DICT
        Created by readJSONDictionnary(). Associate each tree species in the
        simulation (by default, the json input contains almost every tree species
        in Canada) to a harvest target category (hardwoods or softwoods).

    Returns
    -------
    A dataframe containing one row per stand, and different columns that indicate
    their attributes : Their total biomass, their biomass for each of the volume targets
    defined in woodVolumeTargets, their age, their type.

    """

    # A dataframe used to determine the stands based on 5 criteria : total biomass
    # or biomass for one of the biomass targets.
    standRankingDf = pd.DataFrame(standCoordinatesDict.keys(), columns=(["standID"]))
    dictOfArrays = {"Total Biomass":list(),
                    "Age":list(),
                    "Type":list(),
                    "Management Unit":list()}
    for target in woodVolumeTargets.keys():
        dictOfArrays[target] = list()
    for standID in standCoordinatesDict.keys() :
        if standID in standCompositionDict:
            totalBiomass = 0
            for target in woodVolumeTargets.keys():
                dictOfArrays[target].append(GetBiomassInstand(standCompositionDict,
                                                              standID,
                                                              # This snippet retrieves all species for the current target
                                                              [key for key, val in speciesTargetsDict.items() if val == target]))
                totalBiomass += dictOfArrays[target][-1]
            dictOfArrays["Total Biomass"].append(totalBiomass)
            dictOfArrays["Age"].append(standAgeDict[standID])
            dictOfArrays["Type"].append(forestTypesStandsDict[standID])
            dictOfArrays["Management Unit"].append(standManagementUnitDict[standID])
        else:
            for key in dictOfArrays.keys():
                dictOfArrays[key].append(0)
    standRankingDf["Total Biomass"] = dictOfArrays["Total Biomass"]
    for target in woodVolumeTargets.keys():
        standRankingDf[target] = dictOfArrays[target]
    standRankingDf["Age"] = dictOfArrays["Age"]
    standRankingDf["Type"] = dictOfArrays["Type"]
    standRankingDf["Management Unit"] = dictOfArrays["Management Unit"]
    
    return standRankingDf


def prepareBiomassHarvestParameterFile(speciesList, 
                                       biomassHarvestParameterFileTemplate,
                                       outputFile):
    """
    Function used to read the template of the Biomass Harvest parameter file,
    and prepare it for usage with Magic Harvest.
    The goal of this preparation is to remove some dummy parameters (used for the
    initialization of Biomass Harvest), and replace them with the correct instructions
    that refer to the species used is the simulation.
    The prepared file will then be the one that will be used to re-load the parameters
    of Biomass Harvest.
    
    Parameters
    ----------
    speciesList : LIST
        Generated by readSpeciesList(). Contains the species simulated in your
        simulation.
    biomassHarvestParameterFileTemplate : STRING
        Path to the file biomassHarvestParameterFileTemplate.txt used for MHS-CBAU.
        This must be the empty template that Magic Harvest will fill out.
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are. This is because
        the working directory used by Magic Harvest will be the one used by LANDIS-II,
        which is the one where the scenario file is located. As such, if you scenario
        file is located in /SimulationFolder/scenario.txt, and if the template
        file is in /SimulationFolder/inputs/harvest/biomassHarvestParameterFileTemplate.txt, then
        the path you should put must be ./inputs/harvest/biomassHarvestParameterFileTemplate.txt.
    outputFile : STRING
        Path to the file that the script will write to, containing the full instructions.
        WARNING : This path must be the same as the one used in the parameter "HarvestExtensionParameterFile"
        in the parameter file of magic harvest, as this is the file that magic harvest
        will use to re-load the parameters of Biomass Harvest.


    """

    # Step 1: Read template file
    with open(biomassHarvestParameterFileTemplate, 'r') as f:
        content = f.read()

    # Step 2: Remove warning blocks
    warning_block_1 = r">> WARNING : The following line is not used in the simulation\..*?CohortsRemoved ClearCut"
    content = re.sub(warning_block_1, '', content, flags=re.DOTALL)

    warning_block_2 = r">> WARNING : The following line is used to indicate to Magic Harvest\s*\n>> that it must write the instructions for this prescription\."
    content = re.sub(warning_block_2, '', content, flags=re.DOTALL)

    # Step 3: Define prescription formats
    prescriptions = {
        '>> MagicHarvest_ShelterwoodFristPassPrescription': '1-49(100%) 50-999(80%)',
        '>> MagicHarvest_SeedTreeFirstPass': '1-49(100%) 50-999(98%)',
        '>> MagicHarvest_ShelterwoodOrSeedTreeSecondPass': '50-999(100%)',
        '>> MagicHarvest_ClearcutPrescription': '11-999',
        '>> MagicHarvest_SelectionCutting': '30-999(30%)',
        '>> MagicHarvest_Thinning': '1-30(80%) 31-50(66%) 51-70(60%) 71-90(60%) 91-100(40%) 101-120(5%)'
    }

    # Step 4: Replace keywords with species instructions
    for keyword, instruction_format in prescriptions.items():
        if keyword in content:
            # Remove 4 blank lines before the keyword
            # These lines result from previous operations
            pattern = r'\n\n\n\n' + re.escape(keyword)
            content = re.sub(pattern, '\n' + keyword, content)
    
            # Build replacement text
            replacement = "CohortsRemoved SpeciesList\n"
            replacement += ">> Species \t   Cohorts removed\n"
            replacement += ">> ------- \t   ---------------\n"
    
            for species in speciesList:
                replacement += f"   {species} \t  {instruction_format}\n"
    
            content = content.replace(keyword + '\n', replacement)
       
    # Step 5: Write output file
    with open(outputFile, 'w') as f:
        f.write(content)
    
    print(f"    MHS-CBAU :  Successfully processed {len(speciesList)} species")
    print(f"    MHS-CBAU :  Output written to: {outputFile}")


def prepareVolumeHarvestTargetForTimestep(harvestTargetsDict, timestepLength):
    """
    Prepares the volume target to harvest with commercial prescriptions for the
    given timestep. Does so by multiplying the annual harvest targets (contained
    in harvestTargetsDict, and normally loaded with readJSONDictionnary()) by
    the length of a time step (read from the Biomass Harvest Template file with
    biomassHarvestParameterFileParser()).

    Parameters
    ----------
    harvestTargetsDict : DICT
        Contains the content of annualHarvestTargets.json, which define the
        wood volume target (for commercial treatments) and the area targets
        (for non commercial treatments) for the year. The wood volume targets
        are separated accross several type of wood species (Hardwoods and softwoods
        in MHS-CBAU).
    timestepLength : INT
        Length of a time step in your simulation.

    Returns
    -------
    A dictionnary containing the volume targets for the years, one key per
    type of wood species.

    """
    
    dictVolumeTargetsForYear = dict()
    
    for target in harvestTargetsDict["volume"]:
        dictVolumeTargetsForYear[target] = harvestTargetsDict["volume"][target] * timestepLength
        
    return(dictVolumeTargetsForYear)


#%% FUNCTIONS TO MAKE THE MANAGEMENT DECISIONS
# All of the functions used during the decisional process (where to
# use each prescription for the given timestep).

def CheckIfHarvestTargetsReached(volumeTargetDicts,
                                 volumeTargetCounterDict):
    """
    Checks if the harvest volume target have been reached.

    Parameters
    ----------
    volumeTargetDicts : DICT
        Dictionnary containing the volume targets (e.g. we must harvest X
        quantity of wood for target A, etc.).
    volumeTargetCounterDict : DICT
        Dictionnary containing an account of how much wood volume has been already
        harvested for each target (e.g. we have already harvested X quantity of wood
        for target A, etc.).

    Returns
    -------
    A boolean; True means that all of the targets have been filled. False means
    that some wood targets are yet not filled.

    """
    allTargetsReached = True
    for target in volumeTargetDicts.keys():
        # We allow a variation of 1% to say that the target is indeed reached
        if volumeTargetCounterDict[target] < volumeTargetDicts[target]*0.99:
            allTargetsReached = False
    return(allTargetsReached)


def EstimateMerchantableVolumeHarvested(listOfStandIDs,
                                        standCompositionDict,
                                        volumeTargetSpeciesDict,
                                        prescription,
                                        prescriptionParameters,
                                        woodDensityDict,
                                        merchantableAbovegroundRatios,
                                        standsEcozones,
                                        coefficientRawToNetVolumes):
    """
    Computes the merchantable harvested by a prescription in a list of stands,
    taking into account the stand composition and the particularities
    of each prescription. This volume is computed based on the aboveground biomass of each
    age cohort (in Mg), which is translated into m3 of net merchantable volume based on three things :
    1. The ratio of merchantable biomass to aboveground biomass,
    2. the wood density (Mg => volume).
    3. An additional coefficient to remove volume from brut to net (can represent
    a rate of defect or unusability of the wood, etc.)

    Parameters
    ----------
    listOfStandIDs : LIST
        List containing all of the stand IDs for which we want to get the volume
        harvested.
    standCompositionDict : DICT
        Contains the composition of each stand. Generated by readVegetationInLandscape().
    volumeTargetSpeciesDict : DICT
        Dictionnary containing the list of species in each of our wood volume targets
        (normally, hardwood and softwood).
    prescription : String
        Name of the forest cut/prescription to use. Must be one of the name that
        was in the Biomass Harvest parameter text file read by biomassHarvestParameterFileParser().
    prescriptionParameters : DICT
        Dictionnary returned by biomassHarvestParameterFileParser(), which contains
        the parameters for each prescription.
    woodDensityDict : DICT
        Dictionnary containing the wood density of each species. Normally read by readJSONDictionnary().
    merchantableAbovegroundRatios : DICT
        Dictionnary containing the merchantable biomass to aboveground biomass ratios
        for each tree species. Normally read by readJSONDictionnary().
    standsEcozones : DICT
        Contains the combo of ecozone/province in which the stand is. Must be the same
        identification code as the ones used in merchantableAbovegroundRatios. Used
        to retrieve the right ratio for the spatial position of the stand.
    coefficientRawToNetVolumes : DOUBLE OR DICT
        Either a single value being a percentage to reduce the raw volume of wood
        to net (representing defects and other losses), or a dictionnary containing
        a coefficient for each species.
        WARNING : Must be a percentage of volume that will be reduced or not used. For example,
        7% reduction or 0.07. Don't use 93% in this example, e.g. the percentage of wood kept.

    Returns
    -------
    A dictionnary indicating how much wood volume will be harvested in the
    list of stands (listOfStandIDs) if they are harvested by the prescription
    (prescription) for each of the volume targets.

    """

    # We initialize the dict to return at 0 for all targets
    dictToReturn = dict.fromkeys(set(volumeTargetSpeciesDict.values()), 0)
    
    for standID in listOfStandIDs:
        # print("Stand composition : " + str(standCompositionDict[standID]))
        # print("Prescription :" + str(prescription))
        for biomassTarget in dictToReturn.keys():
            # If stand is not in standCompositionDict, it has no biomass/volume.
            # As such, we only consider the stand if it is in the standCompositionDict
            if standID in standCompositionDict:
                volumeHarvestedForTarget = 0
                # We compute the biomass harvested one species at the time for the
                # target
                for species in [key for key, value in volumeTargetSpeciesDict.items() if value == biomassTarget]:
                    # If prescription has keyword "all" for the species, it takes all the biomass
                    # for all cohorts of the species.
                    if species in prescriptionParameters[prescription]["CohortRemoved"]:
                        if prescriptionParameters[prescription]["CohortRemoved"][species] == "All":
                            if species in standCompositionDict[standID].keys():
                                for cohort in standCompositionDict[standID][species].keys():
                                    # we compute the volume for the cohort
                                    # Volume : ((abovegroundBiomass * RatioMerchAboveground(age)) / Wood density (species)) * (1 - coeffRawToNet)
                                    # WARNING : sometimes, cohorts are 1 years old; but no equivalent in dict of ratios. So we round to upper.
                                    if isinstance(coefficientRawToNetVolumes, dict):  # case if coefficientRawToNetVolumes is a dict to change values per species
                                        volumeHarvestedForTarget += (((standCompositionDict[standID][species][cohort] *
                                                                      merchantableAbovegroundRatios[species][str(standsEcozones[standID])]["ratio"])
                                                                     / woodDensityDict[species]['wood_density_value']) *
                                                                     (1 - coefficientRawToNetVolumes[species]))
                                    else: # Case if coefficientRawToNetVolumes is a single value for all species
                                        volumeHarvestedForTarget += (((standCompositionDict[standID][species][cohort] *
                                                                      merchantableAbovegroundRatios[species][str(standsEcozones[standID])]["ratio"])
                                                                     / woodDensityDict[species]['wood_density_value']) *
                                                                     (1 - coefficientRawToNetVolumes))
                                        
                        else:
                            # If no "all" keyword, then we have a list of lists.
                            # Each list is an instruction for a range of age cohort :
                            # index 0 is minimum age; index 1 is maximum age; index 2 is the % of biomass harvested
                            # in the cohorts that are between min and max.
                            for cohortRemovedList in prescriptionParameters[prescription]["CohortRemoved"][species]:
                                if species in standCompositionDict[standID].keys():
                                    for cohort in standCompositionDict[standID][species].keys():
                                        if cohort >= cohortRemovedList[0] and cohort < cohortRemovedList[1]:
                                            if isinstance(coefficientRawToNetVolumes, dict):  # case if coefficientRawToNetVolumes is a dict to change values per species
                                                # Here, formula is a bit different; since we don't take all, we
                                                # modulate the biomass via the percentage associated to the % harvested.
                                                volumeHarvestedForTarget += (((standCompositionDict[standID][species][cohort] *
                                                                              (cohortRemovedList[2]/100) *
                                                                              merchantableAbovegroundRatios[species][str(standsEcozones[standID])]["ratio"])
                                                                             / woodDensityDict[species]['wood_density_value']) *
                                                                             (1 - coefficientRawToNetVolumes[species]))
                                            else:
                                                # Here, formula is a bit different; since we don't take all, we
                                                # modulate the biomass via the percentage associated to the % harvested.
                                                volumeHarvestedForTarget += (((standCompositionDict[standID][species][cohort] *
                                                                              (cohortRemovedList[2]/100) *
                                                                              merchantableAbovegroundRatios[species][str(standsEcozones[standID])]["ratio"])
                                                                             / woodDensityDict[species]['wood_density_value']) *
                                                                             (1 - coefficientRawToNetVolumes))
                        
                # print("Volume harvesed in stand :" + str(volumeHarvestedForTarget))
                dictToReturn[biomassTarget] += volumeHarvestedForTarget
        
    return(dictToReturn)


def findStandForNewCommercialTreatment(volumeTargetDicts, volumeTargetCounterOverfillDict,
                                       standRankingDf, standIsAlreadyHarvestedDict,
                                       protectedAreasID,
                                       rarityValueBooster = 1000000,
                                       numberOfStandsToReturn = 10):
    """
    This function is used to select a stand for a new commercial treatment
    (i.e. Clearcutting, Shelterwood, Seed-Tree or selection cutting) in order
    to make sure that, by calling this function repeatidly, we will fill out
    our different biomass targets (default in MHS-CBAU : hardwoods and softwoods)
    properly, meaning that we fill them without overflowing overs.
    
    To do that, it creates a new temporary dataframe that will sort the stands
    according to three priority/rules :
        
    1) We want to avoid harvesting trees for a biomass target that is already
    filled as much as possible ("Forbid Harvesting") (example : we have harvested
    enough softwoods and are looking for hardwoods).
    2) We want to prioritize stands with trees of biomass targets for which trees are
    rarest/most mixed with others in the landscape first ("Rarity value") (example :
    if our landscape doesn't have a lot of softwoods, or they are often mixed with
    hardwoods, then we want to prioritize the stands that have as much softwoods
    as possible).
    3) We want to prioritize stands with the most biomass, still taking into
    account rarity, but also how much of a target there is yet to fill ("Valued Biomass")
    
    We create these columns as fast as we can using numpy functions.
    

    Parameters
    ----------
    volumeTargetDicts : Dictionnary
        Dictionnary giving the current filling of our different volume targets
        for the timestep.
    volumeTargetCounterOverfillDict : Dictionnary
        Dictionnary keeping track of how much we have filled our volume targets,
        including information about overfilling of targets.
    standRankingDf : DataFrame
        The dataframe with information about each stand in the landscape used
        to rank them..
    standIsAlreadyHarvestedDict : Dictionnary
        Dictionnary telling us if a stand is already harvested for this time step.
    protectedAreasID : int
        Give the unique ID of the management area that correspond to protected areas
        (e.g. we should not harvest here). If your landscape doesn't have any
        management areas, you can use a negative value (e.g. -999)
    rarityValueBooster : int, optional
        Used to prioritize stands with biomass of relatively rare bioamss
        targets. The default is 1000000. Lower values tend to lower the priority
        of rarer targets. You can tweak to obtain the best filling of targets possible,
        but the default value indicated here seems to work quite well.
    numberOfStandsToReturn : int, optional
        The function will return a list of the "best" stands according to the current
        priorities. The argument define how many stands are returned.
        Lower values will make the algorithm
        re-compute the stand priorities more often, leading to a slower script, but
        for more accuracy in filling the different biomass targets. Higher values
        will make the stand priority values be calculated less often, which will speed
        up things, but might result in harvest targets being overfilled or underfilled.
        10 is a good value to start and results in around 2minutes of selection in a 
        landscape of 4 millions active cells. Reduce it if you are in a smaller landscape with
        smaller targets. You can also increase it if things are too slow to your taste.

    Returns
    -------
    The unique ID of a stand that should be used for harvesting.

    """
    
    # print("First filtering...")
    # We select all stands old enough and available for harvest
    # Here, protected stands (standProtectedDict[standID] == 1) should be unavailable.
    # WARNING : There is no other check for if a stand is protected or not.
    standRankingDfFiltered = standRankingDf[(standRankingDf['Age'] >= 30) & (standRankingDf['Management Unit'] != protectedAreasID) & 
                                            np.array([(not standIsAlreadyHarvestedDict[standID]) for standID in standRankingDf['standID']])]
    # We display a warning and return a special value if no stand is available
    # for harvesting.
    if len(standRankingDfFiltered) == 0:
        print("    MHS-CBAU :  WARNING : MagicHarvest script tried to do commercial treatments, but all stands are either younger than 30 years old, protected, or already harvested.")
        return("NO STAND SELECTED")    
    
    dictTargetNotReached = dict()
    dictOfRarityValues = dict()
    
    # print("Forbid harvesting...")
    # Forbid Harvesting
    for target in volumeTargetCounterOverfillDict:
        if volumeTargetCounterOverfillDict[target] < volumeTargetDicts[target]:
            dictTargetNotReached[target] = 1
        else:
            dictTargetNotReached[target] = 0
    # We start with every stand not forbiden
    listForbidenStands = [1] * len(standRankingDfFiltered["Total Biomass"])
    for target in volumeTargetCounterOverfillDict:
        # If target is reached, we indicate 0 (forbiden) where trees of this taret are there, 1 (OK for harvest) where they are not
        if dictTargetNotReached[target] == 0 :
            listForbidenStands = np.multiply(listForbidenStands, np.where(standRankingDfFiltered[target] > 0, 0, 1))

    standRankingDfFiltered["Forbid Harvesting"] = listForbidenStands
    
    # print("Rarity value...")
    # Rarity value
    for target in volumeTargetCounterOverfillDict:
        # Rarity is the biomass for this target divided by the total biomass (for all targets) 
        dictOfRarityValues[target] = (1-(standRankingDfFiltered[target].sum()/standRankingDfFiltered["Total Biomass"].sum()))
    
    maximumRarity = [0]*len(standRankingDfFiltered["Total Biomass"])
    for target in volumeTargetCounterOverfillDict:
        maximumRarity = np.maximum(maximumRarity, np.where(standRankingDfFiltered[target] > 0, 1, 0) * [dictOfRarityValues[target] * dictTargetNotReached[target]])
    
    standRankingDfFiltered["Rarity value"] = maximumRarity
    
    # Here, we compute a value called "Valued Biomass".
    # For each biomass target (hardwood and softwood by default in the MHS-CBAU
    # approach), we multiply the amount of biomass of the target in each stand
    # by a factor that depends on the overall rarity of the target in the landscape,
    # and another that is about how the targets are currently filled.
    # This is done so that the algorithm can choose stands with the biomass of
    # relatively rare target first to that they get filled.
    # Here, I use a power function (with rarityValueBooster as a exponent,
    # with a default value of 1000000) to help to increase the difference between
    # the value of the biomass of each target in each stand, so as to distinguish
    # between targets. This is because rare targets are often so rare in stands
    # that even if the rarity value of a target not rare at all is small,
    # it's not small enough to prioritize the biomass of the rare targets.
    # The power function allows us to increase the distance between rarity values.
    # You can tweak the value of rarityValueBooster to change the behavior.
    # Higher values will prioritize rarer target very much/too much; lower values
    # will give more weight to the targets that are not rare in the landscape.
    # You can do trial and error by look at the filling of the targets and see
    # if it corresponds to what you're looking for.
    # If found 1000000 to be a good sweet spot.
    # print("Valued biomass...")
    standRankingDfFiltered["Valued Biomass"] = sum(
        standRankingDfFiltered[target] * 
        (1000000 ** dictOfRarityValues[target]) * 
        np.maximum(0, 1 - volumeTargetCounterOverfillDict[target] / volumeTargetDicts[target])
        for target in volumeTargetDicts.keys()
    )
    
    # We sort the temporary dataframe according to the three priorities :
    # If stands are forbiden for harvesting; if they contain rare biomass;
    # and if they contain biomass that we need to fill our targets.
    # Solution to avoid sorting : we just take the bests of the list, without
    # sorting everybody compared to each other.
    # print("Nlargest selection...")
    standIDs = standRankingDfFiltered.nlargest(numberOfStandsToReturn, ["Forbid Harvesting", "Rarity value", "Valued Biomass"])["standID"].tolist()
    if len(standIDs) == 0:
        raise ValueError("    MHS-CBAU : ERROR : No stands returned by findStandForNewCommercialTreatment(). There must be an error. Please try debugging.")
    return(standIDs)


def GetBiomassInstand(standCompositionDict, standID, listOfSpecies):
    """
    Retrieves the total biomass in a stand for a list of species.
    
    Parameters
    ----------
    standCompositionDict : DICT
        Contains the composition of each stand. Generated by readVegetationInLandscape().
    standID : INT
        ID of the stand for which we want the biomass.
    listOfSpecies : LIST
        List of species name for which we want to get the biomass.

    Returns
    -------
    Returns a single biomass value.

    """
    sumOfBiomass = 0
    for species in listOfSpecies:
        if species in standCompositionDict[standID]:
            sumOfBiomass += sum(standCompositionDict[standID][species].values())
    return(sumOfBiomass)


def harvestStands(managementMap, standsList, standCoordinatesDict, prescriptionID):
    """
    Edits the management map to indicate a list of stands as harvested with
    a given prescription ID. Returns the modified management map.

    Parameters
    ----------
    managementMap : NUMPY ARRAY
        Numpy array of the same dimensions as the simulated landscape, filled with
        zeroes before the decisional process, that will then be used to create
        the management map once the decisions are done.
    standsList : LIST
        List of stands that have been selected for harvesting with a given prescription.
    standCoordinatesDict : DICT
        Dictionnary containing the coordinates of the pixels in each given stand.
        Created by readingStandsCoordinates().
    prescriptionID : INT
        Code of the prescription to insert. Normally found in the prescriptionParameters
        dictionnary which have been generated by biomassHarvestParameterFileParser()
        and modified if planting prescriptions have been added.

    Returns
    -------
    A tuple containing the updated version of the management map (with the new
    harvested pixels indicated), and the number of pixels harvested.

    """
    numberOfPixelsHarvested = 0
    for standID in standsList:
        for pixel in standCoordinatesDict[standID]:
            managementMap[pixel] = prescriptionID
            numberOfPixelsHarvested += 1
    return(managementMap, numberOfPixelsHarvested)


def PreparingPlantations(prescription,
                         standsHarvestedID,
                         prescriptionParameters,
                         plantingPrescriptionParameters,
                         managementMap,
                         standCompositionDict,
                         standCoordinatesDict,
                         speciesToPlantCommercial):
    """
    Chooses what planting to do according to the stand in question (its
    composition) and the prescription used.
    
    Returns an updated prescriptionParameters dictionnary (with new planting
    prescriptions if needed) and an updated management map (with the ID of the
    prescriptions with planting included).
                                           
    This is the function where the behavior of different planting strategies
    can be implemented. For MHS-CBAU, it only contains the 20%_Commercial
    strategy, which aims to plant commercial species.
                                                



    Parameters
    ----------
    prescription : STRING
        Name of the forest cut/prescription to use. Must be one of the name that
        was in the Biomass Harvest parameter text file read by biomassHarvestParameterFileParser().
    standsHarvestedID : TYPE
        DESCRIPTION.
    prescriptionParameters : DICT
        Dictionnary returned by biomassHarvestParameterFileParser(), which contains
        the parameters for each prescription.
    plantingPrescriptionParameters : DICT
        Dictionnary returned by biomassHarvestParameterFileParser(), similar to
        prescriptionParameters, but contains the infos of the prescriptions with
        planting that we are going to create on-the-fly during the decisions.
    managementMap : NUMPY ARRAY
        Numpy array of the same dimensions as the simulated landscape, filled with
        zeroes before the decisional process, that will then be used to create
        the management map once the decisions are done.
    standCompositionDict : DICT
        Contains the composition of each stand. Generated by readVegetationInLandscape().
    standCoordinatesDict : DICT
        Created by readingStandsCoordinates(). Contains the list of pixels
        coordinates for all of the pixels inside a given stand ID.
    speciesToPlantCommercial : LIST
        Commercial tree species we want to plant in the 20%_Commercial strategy.
        I recommand 1-2 species like the black spruce or white spruce.

    Raises
    ------
    ValueError
        If the planting regime indicated in prescriptionParameters (and thus
        comming from the Biomass Harvest Parameter file) for the prescription
        is not implemented in this function.

    Returns
    -------
    A tuple containing :
        - The updated version of plantingPrescriptionParameters
        - The updated managementMap array
        - The number of pixels harvested

    """
    
    # We compute what is to be planted according to what's inside the pixels of the stand
    # (standID + standCompositionDict) and the type of planting associated
    # to this prescription (prescriptionParameters)
    plantingRegime = prescriptionParameters[prescription]["Planting"]
    
    numberOfPixelsHarvested = 0
    # Could be updated in the future to only plant when the conditions necessitate
    # it (low chances of natural regeneration ?)
    if plantingRegime == "20%_Commercial":
        # In 80% of cases, we won't trigger this planting regime.
        if random.choices([0, 1], weights=[0.8, 0.2], k=1)[0] == 1:
            # For each stand, we detect the commercial species most prevalent
            # in the stand before the cut.
            # Just like the chapter 3 of my thesis :
            # We identify the 2 dominant species of the stand; those are the one that we
            # are going to replant, except if one of them is fir. If that's the case, we
            # replace fir with either black or white spruce.
            speciesToPlantInStand = dict()
            for standID in standsHarvestedID:
                speciesToPlantInStand[standID] = random.choices(speciesToPlantCommercial, k=1)
    
                # For each species to plant, we check if prescription exists. We get its ID.
                # If it doesn't exist, we create a new one, paste it in the harvest txt file
                # Then we get its ID (see PlantationPrescription)
                plantingPrescriptionID, plantingPrescriptionParameters = PlantationPrescription(prescription,
                                                                                                speciesToPlantInStand[standID],
                                                                                                prescriptionParameters,
                                                                                                plantingPrescriptionParameters)
                
                # We put the ID of the prescriptions in the management map : for this
                # prescription type, we uniformemly plant in all cells of the stand
                for pixel in standCoordinatesDict[standID]:
                    managementMap[pixel] = plantingPrescriptionID
                    numberOfPixelsHarvested += 1

        # If planting regime wasn't triggered, we simply harvest with the non-planting version
        # Of the prescription
        else:
            managementMap, numberOfPixelsHarvested = harvestStands(managementMap,
                                                                   standsHarvestedID,
                                                                   standCoordinatesDict,
                                                                   prescriptionParameters[prescription]["PrescriptionID"])
    else:
        raise ValueError("    MHS-CBAU : ERROR : Plantation type " + str(plantingRegime) + " not recognized.")

    # We return prescriptionParameters, which is updated with the new planting temporary prescriptions
    # We also return the management map, now updated too
    return(plantingPrescriptionParameters, managementMap, numberOfPixelsHarvested)


def PlantationPrescription(prescription, speciesToPlant, prescriptionParameters, plantingPrescriptionParameters):
    """
    Checks if there is already a planting prescription in the prescriptions
    dictionnary like the one we want; if not, create a new one, and prepare the prescription text
    to paste the harvest parameter file template at the end of the script.
    
    Returns the ID of the new prescription + the edited prescriptionParameters dictionnary.

    Parameters
    ----------
    prescription : STRING
        Name of the forest cut/prescription to use. Must be one of the name that
        was in the Biomass Harvest parameter text file read by biomassHarvestParameterFileParser().
    speciesToPlant : LIST
        List of species we want to plant with the prescription.
    prescriptionParameters : DICT
        Dictionnary returned by biomassHarvestParameterFileParser(), which contains
        the parameters for each prescription.
    plantingPrescriptionParameters : DICT
        Dictionnary returned by biomassHarvestParameterFileParser(), similar to
        prescriptionParameters, but contains the infos of the prescriptions with
        planting that we are going to create on-the-fly during the decisions.

    Returns
    -------
    A tuple containing :
        - The ID of the new planting prescription we've just created.
        - The updated plantingPrescriptionParameters dictionnary with a possible new
        planting prescription included.
        
    prescriptionParameters is not edited or updated in this function, and is
    thus not returned.

    """
    
    # The speciesToPlant can be a list or an individual species (string)
    if isinstance(speciesToPlant, list):
        # We remove duplicates in the list; might happen !
        speciesToPlantNoDups = list(set(speciesToPlant))
        plantingPrescriptionName = prescription + "-Planting:"
        for species in speciesToPlantNoDups:
            plantingPrescriptionName += species + "-"
        plantingPrescriptionName = plantingPrescriptionName[0:-1] # remove superfluous "-"
    else:
        plantingPrescriptionName = prescription + "-Planting:" + speciesToPlant
    
    # First case : it already exists. We just get the ID.
    if len(plantingPrescriptionParameters) > 0 and plantingPrescriptionName in plantingPrescriptionParameters.keys():
        plantingPrescriptionID = plantingPrescriptionParameters[plantingPrescriptionName]["PrescriptionID"]
    
    # Second case : it doesn't exist. We create it.
    else:
        # We fill the dictionnary with a new prescription that is similar to the one
        # with its regular name
        plantingPrescriptionParameters[plantingPrescriptionName] = dict()
        # We register the ID of this new planting prescription
        # In the management map we're creating, 0 = no forest, 1 = forest non harvested
        # So, prescription ID start at 2. Then, we add all the count of the non-planting and planting
        # prescriptions, and this gives us the ID that this latest prescription should have 
        plantingPrescriptionID = 1 + len(prescriptionParameters.keys()) + len(plantingPrescriptionParameters.keys())
        plantingPrescriptionParameters[plantingPrescriptionName]["PrescriptionID"] = plantingPrescriptionID
        # We copy the Fullstring of the original prescription to edit it
        # We don't need the other fields appart from it and PrescriptionID
        if plantingPrescriptionName not in plantingPrescriptionParameters:
            raise ValueError("Error with plantingPrescriptionName : " +  str(plantingPrescriptionName) + " is not in " + str(plantingPrescriptionParameters.keys()) )
        if prescription not in prescriptionParameters:
            raise ValueError("Error with prescription : " + str(prescription) + " is not in " + str(prescriptionParameters.keys()) )
        plantingPrescriptionParameters[plantingPrescriptionName]["FullString"] = prescriptionParameters[prescription]["FullString"].copy()
        # We edit the FullString to add a line concerning planting
        if isinstance(speciesToPlant, list):
            lineToAppend = "Plant "
            for species in speciesToPlantNoDups:
                lineToAppend += species + " "
            lineToAppend = lineToAppend[0:-1] # remove superfluous space
        else:
            lineToAppend = "Plant " + speciesToPlant
        lineToAppend = lineToAppend + "\n"
        plantingPrescriptionParameters[plantingPrescriptionName]["FullString"].append(lineToAppend)
        # We also edit it to put the right prescription name
        plantingPrescriptionParameters[plantingPrescriptionName]["FullString"][0] = "Prescription " + str(plantingPrescriptionName)
        # We remove any commented line for cleaner output
        filtered_lines = [line for line in plantingPrescriptionParameters[plantingPrescriptionName]["FullString"]
                          if not line.startswith(">> ")]
        plantingPrescriptionParameters[plantingPrescriptionName]["FullString"] = filtered_lines
        # Wondering why we're just copying the full string of the original prescription,
        # and not the other parameters in prescriptionParameters ? Simple : we don't need them !
        # The other functions will use prescriptionParameters to get the info they need.
        # The full string of these new planting prescriptions are only needed to write them
        # in the Biomass Harvest parameter text file we're going to prepare at the end.
        
    return(plantingPrescriptionID, plantingPrescriptionParameters)


def standHarvestPropagationWithRestriction(standID,
                                           maximumSizeToReach,
                                           cellSize,
                                           standNeighboursDict,
                                           standCoordinatesDict,
                                           standAgeDict,
                                           standManagementUnitDict,
                                           protectedAreaCode,
                                           standIsAlreadyHarvestedDict,
                                           avoidYoungStands = True,
                                           optionalRestrictionList = "None"):
    """
    Same as standHarvestPropagation(), but uses a dictionnary that associates
    a zoning code (e.g. protected area) to limit the propagation to the right
    stands, as well as the code to keep.

    Parameters
    ----------
    standID : INT
        ID of the stand from which the propagation should start.
    maximumSizeToReach : INT
        Maximum size that the propagation can reach, in integer format, and in
        hectares. Should come from the value returned by randomSelectCutSizeForPrescription().
        WARNING : Be sure that this size is in hectares ! 
    cellSize : INT or DOUBLE
        Size of the side of one of your cells or pixels in your LANDIS-II simulation,
        in meters. 
        WARNING : Be sure that it is expressed in meters !
    standNeighboursDict : DICT
        Dict containing the list of neighbouring stands for a given stand.
        Created by readingStandsNeighbors().
    standCoordinatesDict : DICT
        Created by readingStandsCoordinates(). Contains the list of pixels
        coordinates for all of the pixels inside a given stand ID.
    standAgeDict : DICT
        Created by readingStandsAges(). Contains the age of the stands
        (average of the age of the oldest cohorts in each pixels of the stand).
    standZoningDict : DICT
        Dictionnary that associates a given stand ID to a zoning or management
        area code. Created by readingStandManagementUnit().
    standCodeToRespect : INT
        Code of the zone or management area inside which the stands we propagate
        to must be.
    standIsAlreadyHarvestedDict : DICT
        Stand indicating wherever a stand has already been harvested at this timestep.
        Must return a boolean True or False for a given Stand ID.

    Returns
    -------
    A list of stand harvested (their ID).

    """
    
    listOfHarvestedStands = list()
    frontier = [standID]
    # We compute the convertion between number of cells versus number of hectares
    # It's the m2 of the cells (so, cellSize x cellSize since cellSize is the
    # side of a cell in meters), divided by the meter squares in one hectare (10000).
    cellsToHectare = cellSize*cellSize / 10000
    surfaceHarvested = 0
    
    while surfaceHarvested < maximumSizeToReach and len(frontier) > 0:
        focusStand = frontier.pop(0)
        # If we overeach the maximum surface, we stop here.
        # That is, unless we haven't even selected a single stand ! If so,
        # we will overeach the maximum target so that we can at least return
        # one stand.
        if surfaceHarvested + (len(standCoordinatesDict[focusStand]) * cellsToHectare) > maximumSizeToReach and len(listOfHarvestedStands) > 0:
            break
        else:
            # We only add the stand if it is not too young, not harvested already, and not in a protected area,
            # and if the optional list is activated, it must be in it
            if (standManagementUnitDict[focusStand] != protectedAreaCode and
                not (avoidYoungStands and standAgeDict[focusStand] < 30) and
                not (optionalRestrictionList != "None" and focusStand not in optionalRestrictionList) and
                not standIsAlreadyHarvestedDict[focusStand]):
                
                listOfHarvestedStands.append(focusStand)
                # Here, we compute the surface harvested in hectares using the number of pixels/cells in the stands
                # and the conversion factor from cells to hectares.
                surfaceHarvested += len(standCoordinatesDict[standID]) * cellsToHectare
                for neighbor in standNeighboursDict[focusStand] :
                    if neighbor not in listOfHarvestedStands:
                       frontier.append(neighbor) 
    if len(listOfHarvestedStands) == 0:
        raise ValueError("\n     MHS-CBAU : ERROR : listOfHarvestedStands returned by standHarvestPropagationWithRestriction contained no stand. This is not normal. " +
                         "\n surfaceHarvested : " + str(surfaceHarvested) + "; maximumSizeToReach : " + str(maximumSizeToReach) + "; len(frontier) : " + str(len(frontier)) +
                         "\n Info on starting stand : Protected ? " + str(standManagementUnitDict[standID]) + "; Age ? " + str(standAgeDict[standID]) + "; Harvested ? " + str(standIsAlreadyHarvestedDict[focusStand]))
    return(listOfHarvestedStands)

#%% FUNCTIONS FOR RANDOM CHOICES
# Several decisions are done with random choices based on weighted probabilities.
# These are the functions that take care of it.

def randomSelectForestCutForForestType(dictProbabilitiesForestCutsPerForestType, stand_type):
    """
    Randomly select a forest cut treatment based on probability weights loaded
    with loadDecisionMatrix().

    Parameters
    ----------
    dictProbabilitiesForestCutsPerForestType : DICT
        Nested dictionary where first key is stand type and second key is 
        treatment type, with values representing probability weights.
        Normally loaded with loadDecisionMatrix().
    stand_type : STRING
        The stand type to select a treatment for (e.g., 'Even-aged and shade tolerant').

    Returns
    -------
    STRING
        The selected forest cut treatment (e.g., 'Clearcutting', 'Shelterwood').
    """
    if stand_type not in dictProbabilitiesForestCutsPerForestType:
        raise KeyError(f"    MHS-CBAU : Stand type '{stand_type}' not found in dictionary")

    treatments = dictProbabilitiesForestCutsPerForestType[stand_type]

    # Extract treatments and their weights
    treatment_names = list(treatments.keys())
    weights = list(treatments.values())

    if sum(weights) == 0:
        raise ValueError(f"    MHS-CBAU : All probability weights are zero for stand type '{stand_type}'")

    # Use random.choices for weighted random selection
    selected_treatment = random.choices(treatment_names, weights=weights, k=1)[0]

    return selected_treatment


def randomSelectCutSizeForPrescription(cut_type, dictForestCutSizesDistribution):
    """
    Randomly sample a forest cut size based on the cut type's probability distribution
    loaded with loadForestCutSizesProbabilities() .

    Selects a bin upper bound value using weighted random sampling, where the weights
    are the probabilities associated with each bin for the specified cut type.

    Parameters
    ----------
    cut_type : STRING
        The forest cut type (e.g., "Clearcut", "Shelterwood").
    dictForestCutSizesDistribution : DICT[STRING, Dict[STRING, List[float]]]
        Dictionary containing forest cut distributions with structure:
        {cut_type: {"bin_upper_bounds": [...], "probabilities_percent": [...]}}
        Normally loaded with loadForestCutSizesProbabilities().

    Returns
    -------
    FLOAT
        A randomly selected cut size (bin upper bound) based on the probability distribution.
        To be used to restraint the size of the cut afterwards.
    """
    cut_data = dictForestCutSizesDistribution[cut_type]
    bin_upper_bounds = cut_data['bin_upper_bounds']
    probabilities = cut_data['probabilities_percent']

    return random.choices(bin_upper_bounds, weights=probabilities, k=1)[0]

#%% FUNCTIONS TO WRITE FILES
# Used to write outputs (rasters, text files, etc.)


def writeNewRasterDataInt16(rasterDataArray, pathOfTemplateRaster, pathOfOutput):
    """
    Write a numpy array to a new GeoTIFF file using metadata from a template raster.

    This function creates a new raster file with the same geospatial properties 
    (coordinate reference system, geotransform, dimensions) as a template raster,
    but populated with data from the provided numpy array. The output is saved as
    a single-band Int16 GeoTIFF with a nodata value of 0.

    Parameters
    ----------
    rasterDataArray : numpy.ndarray
        2D numpy array containing the raster data to write. Shape must match
        the template raster dimensions (rows, cols).
    pathOfTemplateRaster : str
        File path to the template raster from which geospatial metadata 
        (CRS, transform, dimensions) will be copied.
    pathOfOutput : str
        File path where the new GeoTIFF will be saved.

    Returns
    -------
    None
        The function writes directly to disk and returns nothing.

    Notes
    -----
    - Output data type is fixed to Int16 (rasterio.int16)
    - Nodata value is set to 0
    - Output format is GeoTIFF
    - The input array dimensions must match the template raster dimensions
    """
    with rasterio.open(pathOfTemplateRaster) as template:
        metadata = template.meta.copy()
        metadata.update({
            'dtype': 'int16',
            'count': 1,
            'nodata': 0
        })

        with rasterio.open(pathOfOutput, 'w', **metadata) as dst:
            dst.write(rasterDataArray, 1)


def writeHarvestParameterFile(managementMap,
                              pathToBiomassHarvestParameterFile,
                              prescriptionParameters,
                              plantingPrescriptionParameters,
                              managementMapName,
                              timestep):
    """
    Edits the template harvest extension parameter file with the new parameters
    created at this timestep by the script

    Parameters
    ----------
    managementMap : NUMPY ARRAY
        Numpy array of the same dimensions as the simulated landscape, filled with
        zeroes before the decisional process, that will then be used to create
        the management map once the decisions are done.
    pathToBiomassHarvestParameterFile : STRING
        Path to the biomass harvest parameter file, having been prepared already
        by the function prepareBiomassHarvestParameterFile().
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are.
    prescriptionParameters : DICT
        Dictionnary returned by biomassHarvestParameterFileParser(), which contains
        the parameters for each prescription.
    plantingPrescriptionParameters : DICT
        Dictionnary returned by biomassHarvestParameterFileParser(), similar to
        prescriptionParameters, but contains the infos of the prescriptions with
        planting that we are going to create on-the-fly during the decisions.
    managementMap : NUMPY ARRAY
        Numpy array of the same dimensions as the simulated landscape, filled with
        zeroes before the decisional process, that will then be used to create
        the management map once the decisions are done.
    timestep : INT
        Current timestep of the simulation.

    Returns
    -------
    None, the function simply writes the file.

    """
    print("    MHS-CBAU : Writing harvest parameter file...")
    
    # We get all of the unique prescription ID put in the map this timestep
    uniquePrescriptionsForTimestep = np.unique(managementMap)
    # We remove 0 from the prescriptions, as it's only indicative of no prescription
    uniquePrescriptionsForTimestep = np.delete(uniquePrescriptionsForTimestep, np.where(uniquePrescriptionsForTimestep == 0))
    # For each prescription, we write in the harvest.txt parameter file.
    # Whatever the timestep, we reset the harvest.txt file to the initial one, to fill
    # it up again.
    # We read the text of the parameter file
    BioHarvestParameterFile = open(pathToBiomassHarvestParameterFile)
    BioHarvestParameterFileText = BioHarvestParameterFile.readlines()
    
    # We prepare the lines that we will write to force the harvesting where we want it
    # We just create a dict to find the right prescription name for the ID in the map
    prescriptionsNameDict = dict()
    for prescription in prescriptionParameters:
        prescriptionsNameDict[prescriptionParameters[prescription]["PrescriptionID"]] = prescription
    for plantingPrescription in plantingPrescriptionParameters:
        prescriptionsNameDict[plantingPrescriptionParameters[plantingPrescription]["PrescriptionID"]] = plantingPrescription
    # Now we insert the lines
    linesToInsert = list()
    for prescriptionID in uniquePrescriptionsForTimestep:
        linesToInsert.append("\t" + str(prescriptionID) +
                             "\t\t" + str(prescriptionsNameDict[prescriptionID]) +
                             "\t\t100%\t\t" +
                             str(timestep) + "\t" + str(timestep) + "\n")
    # We detect where we will write
    insertionLine = BioHarvestParameterFileText.index(">> PASTE_IMPLEMENTATION_TABLE_HERE\n")
    # We reverse the list to keep the same order of writing in the final file
    linesToInsert.reverse()
    # We write the lines
    for line in linesToInsert:
        BioHarvestParameterFileText.insert(insertionLine, line)
        
    # We also write the lines with the plantation prescriptions
    if len(plantingPrescriptionParameters) > 0: 
        linesToInsert = list()
        for prescription in plantingPrescriptionParameters:
            linesToInsert.extend(plantingPrescriptionParameters[prescription]["FullString"])
            linesToInsert.append("\n\n")
        insertionLine = BioHarvestParameterFileText.index(">> PASTE_PLANTING_PRESCRIPTIONS_HERE\n")
        linesToInsert.reverse()
        for line in linesToInsert:
            BioHarvestParameterFileText.insert(insertionLine, line)
    
    # We finish by changing the name of the maps that we will give to Biomass harvest
    lineToChange = next(i for i, line in enumerate(BioHarvestParameterFileText) if line.startswith("ManagementAreas"))
    # We replace it
    BioHarvestParameterFileText[lineToChange] = "ManagementAreas \"" + managementMapName + "\"\n"
    # We also replace the name of the stand map
    # Actually, it causes errors with the system of partial stand spread ? To delete if resolved.
    # lineToChange = next(i for i, line in enumerate(BioHarvestParameterFileText) if line.startswith("Stands \""))
    # BioHarvestParameterFileText[lineToChange] = "Stands \"" + managementMapName + "\"\n"
    # We save the parameter file
    BioHarvestParameterFile = open(pathToBiomassHarvestParameterFile, "w")
    BioHarvestParameterFileText = "".join(BioHarvestParameterFileText)
    BioHarvestParameterFile.write(BioHarvestParameterFileText)


def WriteTableOfPrescriptionsID(pathToTable,
                                prescriptionParameters,
                                plantingPrescriptionParameters):
    """
    Writes a csv file that indicate the prescriptions IDs in the
    biomass harvest output maps.
    
    As some of these IDs are dynamic and can change from timestep to timestep
    (because of the planting prescriptions which are created on-the-fly
    during the timesteps), this can be useful if you want to look at the maps
    after the simulation is done and know what has been going on.

    Parameters
    ----------
    pathToTable : TYPE
        Path of where to write the table of prescription IDs.
        WARNING : This path must be relative to the folder where your main LANDIS-II scenario file
        is, NOT to the folder where the Magic Harvest Scripts are.
    prescriptionParameters : DICT
        Dictionnary returned by biomassHarvestParameterFileParser(), which contains
        the parameters for each prescription.
    plantingPrescriptionParameters : DICT
        Dictionnary returned by biomassHarvestParameterFileParser(), similar to
        prescriptionParameters, but contains the infos of the prescriptions with
        planting that we are going to create on-the-fly during the decisions.

    Returns
    -------
    None, juste writes the file.

    """
    print("    MHS-CBAU : Writing prescription ID table for Biomass Harvest output maps...")
    
    # We make a quick dictionnary giving the name of a prescription for the corresponding ID
    prescriptionsNameDict = dict()
    for prescription in prescriptionParameters:
        prescriptionsNameDict[prescriptionParameters[prescription]["PrescriptionID"]] = prescription
    for plantingPrescription in plantingPrescriptionParameters:
        prescriptionsNameDict[plantingPrescriptionParameters[plantingPrescription]["PrescriptionID"]] = plantingPrescription
    # We make a sorted list of ID
    listOfID = list(prescriptionsNameDict.keys())
    listOfID = sorted(listOfID)
    listOfOuputs = list()
    listOfOuputs.append(["Prescription name", "Prescription ID - Biomass Harvest maps", "Prescription ID - Magic Harvest maps"])
    for prescriptionID in listOfID:
        # The values between biomass harvest maps and magic harvest maps should be the same.
        listOfOuputs.append([prescriptionsNameDict[prescriptionID], prescriptionID, prescriptionID])
    
    # We write what we need for the .csv file
    with open(pathToTable, 'w+', newline='') as file:
        writer = csv.writer(file)
    
        # Write the data to the CSV file
        writer.writerows(listOfOuputs)
        
def writeRepeatedPrescriptions(folderOfRepeatedPrescriptionsFile, repeatPrescriptionsDict,
                               timestep, timestepLength):
    """
    Saves the data of the repeated prescriptions as a JSON file.

    Parameters
    ----------
    folderOfRepeatedPrescriptionsFile : STRING
        Folder where the file should be created. It will be named dynamically.
    repeatPrescriptionsDict : DICT
        Dictionary containing information about the repeated prescriptions.
        The format of the dictionary is :
            repeatPrescriptionsDict[prescription][groupOfStands] = Repetitions
        Repetitions are years (since beginning of simulation) when the repetition
        should happen. Can be a single value or a list of values.

    Returns
    -------
    None

    """

    # Writing JSON file for repeated prescriptions
    repeatPrescriptionPath = folderOfRepeatedPrescriptionsFile + "/repeatedPrescriptions_" + str(timestep + timestepLength) + ".json"
    with open(repeatPrescriptionPath, "w") as file:
        json.dump(repeatPrescriptionsDict, file, indent=4)
        

def writeMHSCBAU_Log(timestep,
                     timestepLength,
                     logOutputPath,
                     managementMap,
                     volumeTargetCounterDict):
    """
    Writes a log file in csv format (or add a new line if we're not at the
    first timestep, meaning that the file must already exist) that indicates the
    surface harvested and the volume harvested for each wood target according
    to what the script has measured.

    Parameters
    ----------
    timestep : INT
        Current timestep.
    timestepLength : INT
        Length of a timestep in your simulation. Normally read by biomassHarvestParameterFileParser(). 
    logOutputPath : STRING
        Path where the log file should be written.
    managementMap : NUMPY ARRAY
        Numpy array of the same dimensions as your LANDIS-II landscape, filled
        with the prescriptions for the time step.
    volumeTargetCounterDict : DICT
        Dictionnary made by creatingWoodTargetCounterDict() and filled with the
        volume harvested by the commercial prescriptions during the timestep.

    Returns
    -------
    None, just writes the file.

    """
    
    # If first timestep or if the file does not exist, we create the file.
    if timestep == timestepLength or not os.path.exists(logOutputPath):
        if os.path.exists(logOutputPath):
            os.remove(logOutputPath)
        
        # We make the output directories if they don't already exist
        if not os.path.exists(os.path.dirname(logOutputPath)):
            os.makedirs(os.path.dirname(logOutputPath))
            
        listOfHeaders = ["Timestep", "Surface Harvested"]
        for target in volumeTargetCounterDict:
            listOfHeaders.append("Volume " + str(target) + " harvested")
        
        with open(logOutputPath, 'w+', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(listOfHeaders)

    # Then, we write the values
    newRow = [str(timestep), str(np.count_nonzero(managementMap))]
    for target in volumeTargetCounterDict:
        newRow.append(str(volumeTargetCounterDict[target]))
    with open(logOutputPath, 'a', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(newRow)