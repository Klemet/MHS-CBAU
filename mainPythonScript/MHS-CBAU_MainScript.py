# -*- coding: utf-8 -*-
"""
@author: ClÃ©ment Hardy, PhD.
# -*- coding: utf-8 -*-

This is the main script of the MHS-CBAU approach (see https://github.com/Klemet/MHS-CBAU).
This script is called at every timestep of your LANDIS-II simulation
by magic harvest.

It uses the functions contained in the file functionsMHS_CBAU.py.

WARNING : Make sure this script is located in the same folder
as functionsMHS_CBAU.py.
"""

#%% IMPORTING MODULES

import sys, os
import importlib.util
import pandas as pd
import numpy as np
from tqdm import tqdm

# Used to avoid pandas warning/errors in the way I treat data frames
pd.options.mode.copy_on_write = True

#%% INPUTS
# Here are the different input you must give to connect the script to the
# parameters and maps it needs to function.
# Each is clearly explained so as to make it easy to fill.

# WARNING : All paths that you will indicate here must be relative
# to the folder where your main LANDIS-II scenario file is,
# NOT to the folder where this script is ! This is because
# the working directory used by Magic Harvest will be the one used by LANDIS-II,
# which is the one where the scenario file is located. As such, if you scenario
# file is located in /SimulationFolder/scenario.txt, and if the file you have to
# to indicate is at /SimulationFolder/inputs/file.extension, then
# the path you should put must be ./inputs/file.extension.

# WARNING : PATHS INDICATED HERE ARE AN EXAMPLE. You can use a different 
# file structure for your LANDIS-II scenarios and thus use different paths !

# The size of one side of your cells in your LANDIS-II simulation, expressed in meters.
# For example, if you cell is 100x100m (which is the most likely), just put 100.
CELL_SIZE = 100

# Location of the file functionsMHS_CBAU.py that contains the functions necessary
# for this script.
FUNCTIONS_FOR_SCRIPT_PATH = "./input/disturbances/harvesting-MHSCBAU/functionsMHS_CBAU.py"

# Harvest targets JSON file
# Is created by the scripts in scriptsToGenerateInputs/1.VolumeAndAreaTargetsCalculation
# By default, is named harvestTargets.json
# WARNING : If you customize this file, be certain that the volumes are in m3 and the areas in hectares !
HARVEST_TARGETS_JSON_PATH = "./input/disturbances/harvesting-MHSCBAU/annualHarvestTargets.json"

# Probability matrix for choosing a prescription for a stand type
# Is located in /otherInputs
# By default, is named probabilityMatrixCutsVersusStandType.csv
PRESCRIPTION_DECISION_MATRIX_CSV_PATH = "./input/disturbances/harvesting-MHSCBAU/probabilityMatrixCutsVersusStandType.csv"

# Cut size distribution JSON file
# Is created by the scripts in scriptsToGenerateInputs/3.CutSizeProbabilitiesFromQuebecData
# By default, is named cutSizesDistribution.json
CUT_SIZES_PROBABILITIES_JSON_PATH = "./input/disturbances/harvesting-MHSCBAU/cutSizesDistribution.json"

# Merchantable Biomass JSON file
# Is created by the scripts in scriptsToGenerateInputs/4.MerchantableBiomassDictionnary
# By default, is named merchantableBiomassRatiosDictionnary.json
MERCHANTABLE_BIOMASS_JSON_PATH = "./input/disturbances/harvesting-MHSCBAU/merchantableBiomassRatiosDictionnary.json"

# Ecozones raster path
# Raster generated by scriptsToGenerateInputs/4.MerchantableBiomassDictionnary for your study area
# Is used by the script to know which coefficient to use in the merchantable biomass Json (see above)
# depending on the ecozones present in your landscape.
ECOZONES_RASTER_PATH = "../../sharedRasters/EcozonesRaster.tif"

# Wood density JSON file
# Is created by the scripts in scriptsToGenerateInputs/5.WoodDensityBiomassDictionnary
# By default, is named woodDensityDictionnary.json
# WARNING : if you customize this file, be sure that the wood densities are in oven dry mass/fresh volume,
# and that the final units are metric tons per m3 !
WOOD_DENSITY_JSON_PATH = "./input/disturbances/harvesting-MHSCBAU/woodDensityDictionnary.json"

# We define an additional reduction factor for the merchantable volume
# This reduction factor represents the fact that a non-negligeable quantity
# of harvested wood is not used by sawmills because it has defects, but the wood
# targets computed with scriptsToGenerateInputs/1.VolumeAndAreaTargetsCalculation
# are in "Net" roundwood volumes, which usually does not account for this defect
# wood (hence the word "net" compared to "gross").
# You can use your own value here, but be careful : as you make this reduction
# factor bigger, the script will proportionally harvest more wood to compensate
# and reach the net targets.
# The value used here is derived from data gathered by the Ministry
# of Forests of Quebec (see https://diffusion.mern.gouv.qc.ca/public/DGAB/Registre_public/07_Donnees_forestieres/2023-2028/01_Unites_d'amenagement/TB06_matrice_repartition_reduction-produits-essence_2023-2028.xlsx)
# ; it's a document containing reduction factors for
# many tree species in Quebec according to the different magagement units of Quebec
# (Columns CARIE, TRAITS, AJUST_INV and REBUT). 
# If we look at the total reduction across all of these 4 columns, we see that
# it varies between species and management areas between 5%-13%.
# Therefore, I propose to use a number of 7% across all species here.
# You can also use a dictionnary where this reduction factor changes for each species.
NET_WOOD_REDUCTION_VOLUME_FACTOR = 0.07

# Species target type dictionnary
# Is created by the scripts in scriptsToGenerateInputs/6.SpeciesTargetTypeDictionnary
# By default, is named speciesTargetType.json
SPECIES_TARGETS_JSON_PATH = "./input/disturbances/harvesting-MHSCBAU/speciesTargetType.json"

# The template of the Biomass Harvest Parameter file
# Is located in /otherInputs
# By default, is named biomassHarvestParameterFileTemplate.txt
BIOMASS_HARVEST_PARAMETER_TEMPLATE_FILE_PATH = "./input/disturbances/harvesting-MHSCBAU/biomassHarvestParameterFileTemplate.txt"

# The folder where the prepared Biomass Harvest Parameter file should be created
# This file doesn't exist yet; it will be created dynamically by this script
# during the simulation.
# The path you indicate here should be the same as the one used for the parameter
# HarvestExtensionParameterFile in the Magic Harvest parameter file, because
# it's the file that is going to be used to re-load the parameters of biomass harvest.
BIOMASS_HARVEST_PARAMETER_PREPARED_FOLDER_PATH = "./input/disturbances/harvesting-MHSCBAU/"

# The shade tolerance JSON file
# Is located in /otherInputs
# By default, is named shadeToleranceSpeciesCanada.json
SPECIES_SHADE_TOLERANCE_JSON_PATH = "./input/disturbances/harvesting-MHSCBAU/shadeToleranceSpeciesCanada.json"

# The core species parameter file of your LANDIS-II simulation
# It's the file that contains the information about your species longevity,
# sexual maturity, etc. Its location is defined in your the scenario file of
# your simulation (parameter "Species" just after the duration of the simulation).
CORE_SPECIES_PARAMETERS_TXT_PATH = "./input/species_ecoregions/species.txt"

# The folder containing the .csv and .img maps produced by the Biomass Community Ouput
# extension during the simulation.
# Currently, the Biomass Community Output extension does not customize where
# the outputs are made, and they should be created in the same folder as your
# scenario file. But in the future, this might change !
COMMUNITIES_CSV_AND_MAP_FOLDER = "./"

# The raster map containing the location of each stand in your landscape (all
# pixels in a given stand have the same number in it).
STANDS_MAP_PATH = "../../sharedRasters/stands.tif"

# The raster map indicating the management units or zones in your landscape,
# including any protected areas that are in your landscape.
MANAGEMENT_AREAS_MAP_PATH = "../../sharedRasters/management_areas.tif"

# The number/code corresponding to the protected areas in your management area
# map (see above). If there are none, just leave it to -1.
PROTECTED_AREAS_ID = 0

# The 1-2 main commercial tree species in your landscape, which are simulated
# in your LANDIS-II scenario. Indicate their names as they are in your LANDIS-II
# parameter files. These species will be planted after 20% of clearcuts (random choice
# in MHS-CBAU. Write them as a Python list (strings of character between quotes "",
# each item separated by a comma , and the all thing surrounded with square braquets []).
# WARNING : Here is an example with two commercial species (Black spruce, White spruce).
# Be certain to change them !
COMMERCIAL_SPECIES_TO_PLANT = ["PICE.MAR", "PICE.GLA"]

# This is the folder where the outputs of this script will be put.
# This folder will contain the prescription maps made by this script, and the
# file containg the schedule of repeated prescriptions.
FOLDER_FOR_MAGICHARVEST_OUTPUTS = "./output/MHS-CBAU/"

# A boolean (True or False) indicating if you want to delete the files generated
# by Biomass Community Output once the script has finished running
# I truly recommand it as these files take a lot of space. But you might want
# to keep them for analysis purposes.
DELETE_COMMUNITIES_FILES = True

# The number of stands selected per rounds for the algorithm that selects
# stands for new commercial harvesting. Lower values will make the algorithm
# re-compute the stand priorities more often, leading to a slower script, but
# for more accuracy in filling the different biomass targets. Higher values
# will make the stand priority values be calculated less often, which will speed
# up things, but might result in harvest targets being overfilled or underfilled.
# 10 is a good value to start and results in around 2minutes of selection in a 
# landscape of 4 millions active cells. Reduce it if you are in a smaller landscape with
# smaller targets. You can also increase it if things are too slow to your taste.
STANDS_PER_ROUND = 10

#%% ENABLING DEBUG MODE
# The purpose of the debug mode is to test these script outside of a running
# LANDIS-II simulation. For example, you can take outputs from a simulation
# you have already done, put the python scripts (MHS-CBAU_MainScript.py and
# functionsMHS_CBAU.py) next to the outputs, and then run the scripts manually
# (e.g. in Spyder, the equivalent of R studio for Python) to test if they work
# This is useful to do before you include these scripts in your simulations,
# or to understand how they work.

# This boolean enables or disables debug mode
DEBUG_MODE_ENABLED = False

# If debug mode is enabled, we fill in the variables that are normally filled
# by the arguments given to the script by Magic Harvest during a simulation.
if DEBUG_MODE_ENABLED:
    # This line changes the directory where the script will be running.
    # Put the full path to the directory where you have your LANDIS-II outputs
    # You'll be using for the debugging
    os.chdir(r"")
    # This variable will contain the timestep where the script think it will be.
    timestep = 60
    # This will enable the TQDM progress bars for many functions.
    disableTQDM = False
    # This imports Matplotlib to display some graphs for debugging
    import matplotlib.pyplot as plt
    
# If debug mode is disabled, we will get the variables from the arguments
# given to the script by Magic Harvest (see the parameter file template for Magic
# harvest at /otherInputs/magicHarvestParameterFileTemplate.txt) 
else:
    if __name__ == "__main__":
        # Remember : argument at index 0 contains the program name.
        # The arguments 1 will contain the timestep value given by
        # magic harvest through the keyword {timestep}.
        timestep = sys.argv[1]
        timestep = int(timestep)
    # We disable the progress bars of TQDM to not display them in the LANDIS log
    disableTQDM = True


#%% FUNCTIONS
# WARNING : You need to have the functionsMHS_CBAU.py file in the same folder
# as this one for the functions to get properly loaded.

# Create module spec with your desired name
spec = importlib.util.spec_from_file_location("MHS_CBAU", FUNCTIONS_FOR_SCRIPT_PATH)

# Create the module
MHS_CBAU = importlib.util.module_from_spec(spec)

# Execute the module to load its contents
spec.loader.exec_module(MHS_CBAU)


#%% 1. READING INPUTS
# In this section, we are going to read the static inputs (which do not change
# between timestep), and the dynamic inputs for the current timestep.

print("    MHS-CBAU : Reading inputs...")

# Static inputs

harvestTargetsDict = MHS_CBAU.readJSONDictionnary(HARVEST_TARGETS_JSON_PATH)

dictProbabilitiesForestCutsPerForestType = MHS_CBAU.loadDecisionMatrix(PRESCRIPTION_DECISION_MATRIX_CSV_PATH)

dictForestCutSizesDistribution = MHS_CBAU.loadForestCutSizesProbabilities(CUT_SIZES_PROBABILITIES_JSON_PATH)

merchantableAbovegroundRatios = MHS_CBAU.readJSONDictionnary(MERCHANTABLE_BIOMASS_JSON_PATH)

woodDensityDict = MHS_CBAU.readJSONDictionnary(WOOD_DENSITY_JSON_PATH)

volumeTargetSpeciesDict = MHS_CBAU.readJSONDictionnary(SPECIES_TARGETS_JSON_PATH)

speciesShadeToleranceDict = MHS_CBAU.readJSONDictionnary(SPECIES_SHADE_TOLERANCE_JSON_PATH)

speciesList = MHS_CBAU.readSpeciesList(CORE_SPECIES_PARAMETERS_TXT_PATH)

standCoordinatesDict = MHS_CBAU.readingStandsCoordinates(STANDS_MAP_PATH, disableTQDM)

standNeighboursDict = MHS_CBAU.readingStandsNeighbors(STANDS_MAP_PATH, standCoordinatesDict, disableTQDM)

standManagementUnitDict = MHS_CBAU.readingStandManagementUnit(STANDS_MAP_PATH, MANAGEMENT_AREAS_MAP_PATH, disableTQDM)

standsEcozones = MHS_CBAU.readingStandManagementUnit(STANDS_MAP_PATH, ECOZONES_RASTER_PATH, disableTQDM)

BIOMASS_HARVEST_PARAMETER_PREPARED_FILE_PATH = BIOMASS_HARVEST_PARAMETER_PREPARED_FOLDER_PATH + "/biomassHarvestParameterFilePrepared.txt"

MHS_CBAU.prepareBiomassHarvestParameterFile(speciesList,
                                            BIOMASS_HARVEST_PARAMETER_TEMPLATE_FILE_PATH,
                                            BIOMASS_HARVEST_PARAMETER_PREPARED_FILE_PATH)

prescriptionParameters, timestepLength = MHS_CBAU.biomassHarvestParameterFileParser(BIOMASS_HARVEST_PARAMETER_PREPARED_FILE_PATH,
                                                                                    speciesList)


# Dynamic inputs (for the timestep)

standCompositionDict = MHS_CBAU.readVegetationInLandscape(COMMUNITIES_CSV_AND_MAP_FOLDER + "/community-input-file-" + str(timestep- timestepLength) + ".csv",
                                                          COMMUNITIES_CSV_AND_MAP_FOLDER + "/output-community-" + str(timestep- timestepLength) + ".img",
                                                          standCoordinatesDict,
                                                          disableTQDM)

repeatPrescriptionsDict = MHS_CBAU.readRepeatedPrescriptions(FOLDER_FOR_MAGICHARVEST_OUTPUTS, timestep)

standAgeDict = MHS_CBAU.getStandAges(standCoordinatesDict, standCompositionDict)

forestTypesStandsDict = MHS_CBAU.determineForestTypesOfStands(standCompositionDict,
                                                              standCoordinatesDict,
                                                              speciesShadeToleranceDict,
                                                              disableTQDM)

#%% 2. PREPARING OTHER OBJECTS WE NEED
# Here, we prepare some more objects that will be needed to make the management
# decisions afterwards.

print("    MHS-CBAU : Preparing objects...")

# Dict containing the harvest targets for the year
woodVolumeTargets = MHS_CBAU.prepareVolumeHarvestTargetForTimestep(harvestTargetsDict, timestepLength)

# Dict to count how much of the targets we have harvested
volumeTargetCounterDict = MHS_CBAU.creatingWoodTargetCounterDict(woodVolumeTargets)

# Dictionnary to know if a stand is already used for harvesting at this timestep
standIsAlreadyHarvestedDict = MHS_CBAU.creatingStandHarvestTracker(standCoordinatesDict)

# Data frame to rank the stands
standRankingDf = MHS_CBAU.createStandRankingDataFrame(standCoordinatesDict, standCompositionDict,
                                                      forestTypesStandsDict, standManagementUnitDict, standAgeDict,
                                                      woodVolumeTargets, volumeTargetSpeciesDict)

# We prepare a dictionnary that we will fill with information about the prescriptions
# with planting we are going to create dynamically with this script
plantingPrescriptionParameters = dict()

# Map to know were the prescriptions are applied that we will fill during the
# rest of the script
# Each pixel contains either 0 (no harvesting) or the ID of a prescription to apply
# it will be fed to Biomass Harvest as a "fake" management area map to control the
# harvesting where we want it
managementMap = np.zeros_like(MHS_CBAU.getRasterData(STANDS_MAP_PATH))


#%% 3. APPLYING COMMERCIAL REPEATED HARVESTS
# We start the management decision by applying the prescriptions that were
# programmed for repetition at this time step.

print("    MHS-CBAU : Harvesting stands with repeated prescriptions...")


# PREPARING COUNTER OF REPEAT HARVEST
# We don't want repeated harvest to accumulate in the landscape. But if we keep
# triggering new long-term repeated harvest with multiple repeats
# (especially selection cutting) at every time step,
# then they will accumulate and become too prevalent.
# To avoid that, we prepare a counter for each repeated prescription; this counter will be
# used to "skip" the harvest lottery if it lands on a multiple repeat prescriptions
# when creating new ones (see next section).
# This is almost only to stop Selection cutting to become too prevalent in the landscape.
# Each skip will count for a group of stands, as repeated harvests are done by groups of stands.
# WARNING : There are not check to see if a given stand is in a protected area and should not be harvested
# in this section. Normally, this check is done when repeated cuts are programmed in the next section (commercial harvest)
repeatSkipLotteryCounter = dict()
for prescription in prescriptionParameters:
    if prescriptionParameters[prescription]["RepeatMode"] != "none":
        repeatSkipLotteryCounter[prescription] = 0


## DETECTING GROUPS OF STANDS FOR REPEAT HARVESTING
# If no repeated harvest file have been saved for this timestep (i.e. we are at
# the first timestep), then the value of the returned dictionnary will be "noRepeatsForNow".
if repeatPrescriptionsDict != "noRepeatsForNow":
    
    # We define entries that we will remove after the loop to avoid making error
    # by changing the repeatPrescriptionsDict object while we are looping in it.
    prescriptionsToRemove = list()
    
    # Now, we explore the dictionnary to trigger the repeated prescriptions for
    # the timestep.
    for prescription in list(repeatPrescriptionsDict.keys()):
        
        # We define of stands that we will remove after the loop (because all of
        # their repetitions will have been done)
        listOfStandGroupsToRemove = list()
        
        # We explore the stands that have to be harvested with this prescription
        # at this timestep.
        # WARNING : JSON export will save these as strings. We put them back as int here.
        for repeatedStand in repeatPrescriptionsDict[prescription].keys():
            
            # If there is a repetition for this timestep, then we will consider
            # making the repetition :
            if repeatPrescriptionsDict[prescription][repeatedStand][0] == timestep:
                
                # If the repetition is a single repeat with a second phase
                # (e.g. with Shelterwood or seed-tree), we consider the second
                # phase as the prescription
                if "SecondPassPrescription" in prescriptionParameters[prescription]:
                    prescriptionToConsider = prescriptionParameters[prescription]["SecondPassPrescription"]
                else:
                    prescriptionToConsider = prescription
                
                # We compute how much volume will be harvested in this group of
                # stand if we harvest them.
                volumeHarvestedInStand = MHS_CBAU.EstimateMerchantableVolumeHarvested([repeatedStand],
                                                                                      standCompositionDict,
                                                                                      volumeTargetSpeciesDict,
                                                                                      prescriptionToConsider,
                                                                                      prescriptionParameters,
                                                                                      woodDensityDict,
                                                                                      merchantableAbovegroundRatios,
                                                                                      standsEcozones,
                                                                                      NET_WOOD_REDUCTION_VOLUME_FACTOR)

                # We check if overfilling of a volume target
                # (We will fill a harvest target 1% above its limit)
                overeachOfTarget = False
                for biomassTarget in woodVolumeTargets.keys():
                    if (volumeHarvestedInStand[biomassTarget] + volumeTargetCounterDict[biomassTarget]) > (woodVolumeTargets[biomassTarget]*1.01):
                        overeachOfTarget = True
                
                # If there is no overfilling of a harvest target in case we harvest
                # this group of stands, then we harvest them.
                if not overeachOfTarget:
                    
                    # If planting is associated with this prescription, we activate it.
                    # Here, no propagation of the harvest from stand to stand
                    # since we are just repeating a prescription
                    # and the group of stands to harvest is already defined.
                    if prescriptionParameters[prescriptionToConsider]["Planting"] != "none":
                        plantingPrescriptionParameters, managementMap, numberOfPixelsHarvested = MHS_CBAU.PreparingPlantations(prescription,
                                                                                                                               [repeatedStand],
                                                                                                                               prescriptionParameters,
                                                                                                                               plantingPrescriptionParameters,
                                                                                                                               managementMap,
                                                                                                                               standCompositionDict,
                                                                                                                               standCoordinatesDict,
                                                                                                                               COMMERCIAL_SPECIES_TO_PLANT)
                    # If not planting, we do a simple harvesting.
                    else:
                        managementMap, numberOfPixelsHarvested = MHS_CBAU.harvestStands(managementMap,
                                                                                        [repeatedStand],
                                                                                        standCoordinatesDict,
                                                                                        prescriptionParameters[prescriptionToConsider]["PrescriptionID"])
                    
                    # We indicate the stand as harvested.
                    for standID in [repeatedStand]:
                        standIsAlreadyHarvestedDict[standID] = True
                        
                    # We add the volume harvested in the group to the targets
                    for biomassTarget in woodVolumeTargets.keys():
                        volumeTargetCounterDict[biomassTarget] += volumeHarvestedInStand[biomassTarget]
                        
                    # We increase the counter to skip the harvest lottery in the next section
                    # if it has multiple repeat (i.e. is not single repeat)
                    # We look at prescriptionToConsider because there might be a situation
                    # were the second pass is a multiple repeat.
                    if prescriptionParameters[prescriptionToConsider]["RepeatMode"] == "MultipleRepeat":
                        repeatSkipLotteryCounter[prescription] += 1
                    
                    # We remove the harvest repeat we have just dealt with from the list for this stand
                    if len(repeatPrescriptionsDict[prescription][repeatedStand]) > 1:
                        repeatPrescriptionsDict[prescription][repeatedStand].pop(0)
                        # if this is an endless repeat harvest, we add another one
                        if prescriptionParameters[prescription]["RepeatMode"] == "MultipleRepeat":
                            repeatPrescriptionsDict[prescription][repeatedStand].append(repeatPrescriptionsDict[prescription][repeatedStand][-1] + prescriptionParameters[prescription]["RepeatFrequency"])
                    else:
                        # If it was the last repeat, we remove the stand from
                        # the dict; and if no more stands for a prescription,
                        # we remove it too.
                        listOfStandGroupsToRemove.append(repeatedStand)

                # For stands that are not harvested because of target overeach :
                # We simply re-program the next repetitions by shifting them by 1 timestep.
                else:
                    if len(repeatPrescriptionsDict[prescription][repeatedStand]) > 1:
                        repeatPrescriptionsDict[prescription][repeatedStand] = [x + timestepLength for x in repeatPrescriptionsDict[prescription][repeatedStand]]
        
        # Now, we remove the group of stands no no more repetition for this prescription
        for repeatedStand in listOfStandGroupsToRemove:
            if prescription in repeatPrescriptionsDict and repeatedStand in repeatPrescriptionsDict[prescription]:
                del repeatPrescriptionsDict[prescription][repeatedStand]
            if len(repeatPrescriptionsDict[prescription]) == 0:
                prescriptionsToRemove.append(prescription)

    # Finally, we remove the prescriptions that are not used anymore.
    for prescription in prescriptionsToRemove:
        if prescription in repeatPrescriptionsDict:
            del repeatPrescriptionsDict[prescription]


#%% 4. DECIDING NEW COMMERCIAL HARVESTS
# Here, we are going to decide where to use new commercial harvests
# until we fill all of our harvest targets.
# This is the most important part of the script.

print("    MHS-CBAU : Harvesting stands with commercial harvests...")


# If we have enabled debug mode, we will measure how the targets are filled
# through the iterations of the algorithm and display a plot at the end
if DEBUG_MODE_ENABLED:
    dictEvolutionOfTargets = dict()
    for target in woodVolumeTargets:
        dictEvolutionOfTargets[target] = [volumeTargetCounterDict[target]]

# We also prepare a progress bar if needed
if not disableTQDM:
    pbar = tqdm(total=sum(woodVolumeTargets.values()))
    
# This dictionnary is another counter to see if we have filled the targets
# But this one will help us by putting volumes from one accidentally overfilled target
# into the one that is being focused on during a round.
# As such, it does not report "true" volume targets counters, but is used to know when
# to stop. volumeTargetCounterDict will be the one with the true values for
# output purposes.
# We do this because some targets might be difficult to reach without
# filling other targets at the same time (and overfilling them), like when
# a target concerns a species/group of species often mixed with species from
# another target. In this case, we don't want to keep harvesting and overfilling
# other targets just to reach this one; so, we reduce it with volumes from other
# targets.
volumeTargetCounterOverfillDict = volumeTargetCounterDict.copy()

# This is the loop where we will decide of new cuts until our harvest
# targets are reached.
while not MHS_CBAU.CheckIfHarvestTargetsReached(woodVolumeTargets,
                                                volumeTargetCounterOverfillDict):
    
    # We select a stand based on the priority algorithm (see function findStandForNewCommercialTreatment()
    # in functionsMHS_CBAU.py for more information about the algorithm)
    # print("Finding new stand...")
    standIDSelectedMultiple = MHS_CBAU.findStandForNewCommercialTreatment(woodVolumeTargets, volumeTargetCounterOverfillDict,
                                                                          standRankingDf, standIsAlreadyHarvestedDict,
                                                                          PROTECTED_AREAS_ID, STANDS_PER_ROUND)
    
    # print("Stand selected : " + str(standIDSelected))
    
    # If the function returns NO STAND SELECTED, that means that no stands are
    # available for harvesting. If that's so, we just get out of the loop.
    if standIDSelectedMultiple == "NO STAND SELECTED":
        break
    
    # If we have selected a stand, we must now find the right prescription for it
    else:
        for standIDSelected in standIDSelectedMultiple:
        
            # We choose the prescription using the probabilities of the decision matrix.
            # We enter a loop because we will make several attempt to choose a prescription
            # if we have registered some "skips" to do in the section about repeated prescriptions
            # (see section 3 above).
            # print("Selecting prescription...")
            while True:
                prescription = MHS_CBAU.randomSelectForestCutForForestType(dictProbabilitiesForestCutsPerForestType,
                                                                           forestTypesStandsDict[standIDSelected])
                # We skip and redo the choice if the prescription
                # is a repeated one that has been used this turn.
                if prescription in repeatSkipLotteryCounter and repeatSkipLotteryCounter[prescription] > 0:
                    repeatSkipLotteryCounter[prescription] -= 1
                # If not, we continue !
                else:
                    break
            
            # It can happen that the stand we're looking at have been harvested when propagating
            # from a previous stand in standIDSelectedMultiple. If that's the case, we just skip this
            # one.
            if standIsAlreadyHarvestedDict[standIDSelected]:
                continue
            
            # Since we now harvest groups of stands selected with findStandForNewCommercialTreatment
            # according to parameter STANDS_PER_ROUND, we need to check if we have reached
            # the total volume to harvest and stop before we enter the while loop again.
            if MHS_CBAU.CheckIfHarvestTargetsReached(woodVolumeTargets,
                                                            volumeTargetCounterOverfillDict):
                break
            
            # print("Prescription selected for stand : " + str(standIDSelected) + " of type : " + str(forestTypesStandsDict[standIDSelected]) + " : " + str(prescription))
            
            # We check how much volume this prescription will harvest
            # First, we propagate the harvesting to surrounding stands; but we avoid protected areas.
            
            # First, we use a random choice for the size that the cut will have
            # print("Finding cut size...")
            maximumSizeToReach = MHS_CBAU.randomSelectCutSizeForPrescription(prescription, dictForestCutSizesDistribution)
            
            # print("Cut size selected is : " + str(maximumSizeToReach))
            
            # Then, we select the stands that will be harvested by propagating the cut from the initial stand we chose
            # until we get 
            # print("Propagating...")
            standsHarvestedEstimate = MHS_CBAU.standHarvestPropagationWithRestriction(standIDSelected,
                                                                                      maximumSizeToReach,
                                                                                      CELL_SIZE,
                                                                                      standNeighboursDict,
                                                                                      standCoordinatesDict,
                                                                                      standAgeDict,
                                                                                      standManagementUnitDict,
                                                                                      PROTECTED_AREAS_ID,
                                                                                      standIsAlreadyHarvestedDict,
                                                                                      avoidYoungStands = True)
            
            # print("Stands selected by propagation : " + str(standsHarvestedEstimate))
            
            # Then, we estimate the volume of wood that will be harvested by harvesting the stands selected before
            # print("Estimating volume...")
            volumeHarvestedEstimate = MHS_CBAU.EstimateMerchantableVolumeHarvested(standsHarvestedEstimate,
                                                                                   standCompositionDict,
                                                                                   volumeTargetSpeciesDict,
                                                                                   prescription,
                                                                                   prescriptionParameters,
                                                                                   woodDensityDict,
                                                                                   merchantableAbovegroundRatios,
                                                                                   standsEcozones,
                                                                                   NET_WOOD_REDUCTION_VOLUME_FACTOR)
            # for target in volumeHarvestedEstimate.keys():
            #     print("Volume harvested for " + str(target) + " : " + str(volumeHarvestedEstimate[target]))
            
            if sum(volumeHarvestedEstimate.values()) == 0:
                print("    MHS-CBAU : WARNING : Volume estimated for prescription " + str(prescription) +
                      " applied to stands with composition " + str(standsHarvestedEstimate) +
                      " was of 0. That's not supposed to be the case !\n" +
                      "Volumes : " + str(volumeHarvestedEstimate) + "\nComposition :")
                for standWeTriedToHarvest in standsHarvestedEstimate:
                    print("Stand " + str(standWeTriedToHarvest))
                    print(str(standCompositionDict[standWeTriedToHarvest]))
                
            
            ## HARVESTING THE STAND AND PREPARING REPEAT
            
            # print("Harvesting and preparing planting or repeat...")
            # If planting, we activate it.
            if prescriptionParameters[prescription]["Planting"] != "none":
                plantingPrescriptionParameters, managementMap, numberOfPixelsHarvested = MHS_CBAU.PreparingPlantations(prescription,
                                                                                                                       standsHarvestedEstimate,
                                                                                                                       prescriptionParameters,
                                                                                                                       plantingPrescriptionParameters,
                                                                                                                       managementMap,
                                                                                                                       standCompositionDict,
                                                                                                                       standCoordinatesDict,
                                                                                                                       COMMERCIAL_SPECIES_TO_PLANT)
                
            else:
                managementMap, numberOfPixelsHarvested = MHS_CBAU.harvestStands(managementMap,
                                                                                standsHarvestedEstimate,
                                                                                standCoordinatesDict,
                                                                                prescriptionParameters[prescription]["PrescriptionID"])
            
            # We indicate the stands as harvested
            for standHarvested in standsHarvestedEstimate:
                standIsAlreadyHarvestedDict[standHarvested] = True
            
            # If there is repeat, we indicate the stands as repeated
            if prescriptionParameters[prescription]["RepeatMode"] != "none":
                # We initialize the repeat dict if not already done
                if repeatPrescriptionsDict == "noRepeatsForNow":
                    repeatPrescriptionsDict = dict()
                if prescription not in repeatPrescriptionsDict:
                    repeatPrescriptionsDict[prescription] = dict()
                # If multiple repeat, we plan the next 3 repeats
                if prescriptionParameters[prescription]["RepeatMode"] == "MultipleRepeat":
                    listOfRepeats = [(timestep + prescriptionParameters[prescription]["RepeatFrequency"]),
                                     (timestep + prescriptionParameters[prescription]["RepeatFrequency"]*2),
                                     (timestep + prescriptionParameters[prescription]["RepeatFrequency"]*3)]
                    for standRepeated in standsHarvestedEstimate:
                        # Int is added here for the export in JSON format which really needs a simple int for the standID
                        repeatPrescriptionsDict[prescription][int(standRepeated)] = listOfRepeats
                # If simple repeat, we program the next repeat.
                elif prescriptionParameters[prescription]["RepeatMode"] == "SingleRepeat": 
                    for standRepeated in standsHarvestedEstimate:
                        # Int is added here for the export in JSON format which really needs a simple int for the standID
                        repeatPrescriptionsDict[prescription][int(standRepeated)] = [timestep + prescriptionParameters[prescription]["RepeatFrequency"]]
                                
            # We register the volume harvested in the real target counter
            for target in volumeTargetCounterDict.keys():
                volumeTargetCounterDict[target] += volumeHarvestedEstimate[target]
            
            # We register the volume harvested; but this time,
            # we do it in an alternative target counter where the overfill of one
            # target is sent to the other targets that are not yet filled
            # (see beginning of this section).
            for target in volumeTargetCounterOverfillDict.keys():
                # If already filled
                if volumeTargetCounterOverfillDict[target] >= woodVolumeTargets[target]:
                    # We find the targets not filled and give some to them
                    targetsNotFilled = list()
                    for targetTested in woodVolumeTargets:
                        if volumeTargetCounterOverfillDict[targetTested] < woodVolumeTargets[targetTested]:
                            targetsNotFilled.append(targetTested)
                    for targetNotFilled in targetsNotFilled:
                        volumeTargetCounterOverfillDict[targetNotFilled] += volumeHarvestedEstimate[target]/len(targetsNotFilled)
                else:
                    volumeTargetCounterOverfillDict[target] += volumeHarvestedEstimate[target]
            
            # print("Volume harvested : " + str(sum(volumeHarvestedEstimate.values())))
            # We update the progress bar
            if not disableTQDM:
                pbar.update(sum(volumeHarvestedEstimate.values()))
            
            # We register the values to make a graph of their evolution later
            if DEBUG_MODE_ENABLED:
                for target in volumeTargetCounterDict:
                    dictEvolutionOfTargets[target].append(volumeTargetCounterDict[target])

# We close the progress bar
if not disableTQDM:
    pbar.close()


# Display the evolution of the filling of the target through time
# Can choose between the real counter or the alternative counter.
if DEBUG_MODE_ENABLED:
    # Plot the curves
    seqOfRounds = range(0, len(dictEvolutionOfTargets[list(dictEvolutionOfTargets.keys())[0]]), 1)
    colors = plt.cm.tab10.colors  # Standard matplotlib color palette (10 colors)
    
    for i, target in enumerate(dictEvolutionOfTargets):
        color = colors[i % len(colors)]  # Cycle through colors if more targets than colors
        plt.plot(seqOfRounds, dictEvolutionOfTargets[target], label=target, color=color)
        plt.plot(seqOfRounds, [woodVolumeTargets[target]]*len(seqOfRounds), color=color, linestyle='--')
    
    # Add labels and title
    plt.xlabel('Rounds')
    plt.ylabel('Roundwood Targets (m3)')
    plt.title('Evolution of Target filling')
    
    # Show the legend
    plt.legend()
    
    # Display the plot
    plt.show()
    
    # Displays the management map in debug
    # plt.imshow(managementMap)
    
#%% 5. DECIDING AREA-BASED NON COMMERCIAL TREATMENTS
# Some treatments are non commercial (like pre-commercial thinning) : they are
# mostly "education" treatments, done to help a forest stand grow better, or
# grow with the species we want.
# In MHS-CBAU, these treatments are thinning and pre-commercial thinning.
# They do not participate to the harvest targets in volume of wood, but have
# their own area target. See the file harvestTargets.txt generated by the scripts
# in scriptsToGenerateInputs/1.VolumeAndAreaTargetsCalculation.
#
# It is expected that the non commercia treatments have a minimum and maximum age
# stand to apply to them through the keyword >> MagicHarvest_MinMaxAgeStands in the
# Biomass Harvest parameter text file read by biomassHarvestParameterFileParser().

print("    MHS-CBAU : Harvesting stands with non-commercial treatments...")


for nonCommercialTreatment in harvestTargetsDict["area"]:
    # We initialize the counter of the harvested surface
    areaTargetToReach = harvestTargetsDict["area"][nonCommercialTreatment]
    counterAreaHarvested = 0
    cellsToHectare = CELL_SIZE*CELL_SIZE / 10000
    
    # We will choose stands with the most biomass in the age range for the
    # prescription, that is not in a protected area and no harvested yet
    standRankingDfTemp = standRankingDf[(standRankingDf['Age'] <= int(prescriptionParameters[nonCommercialTreatment]["MaximumStandAge"]))
                             & (standRankingDf['Age'] >= int(prescriptionParameters[nonCommercialTreatment]["MinimumStandAge"]))
                             & (standRankingDf["Management Unit"] != PROTECTED_AREAS_ID)]
    standRankingDfTemp = standRankingDfTemp.sort_values(by = ["Total Biomass"], ascending = False)
    
    # Case where no stands are available for harvesting
    if len(standRankingDfTemp) == 0:
        # If that's the case, we go to the next forestType
        print("    MHS-CBAU : WARNING : MagicHarvest script tried to do the non commercial prescription" + str(nonCommercialTreatment) +
              ", but no stands matches the conditions for the prescription.")
        continue
    
    # We look at stands one by one in the pre-selection until surface target is met
    indexStand = 0
    while counterAreaHarvested < areaTargetToReach*0.95 and indexStand < len(standRankingDfTemp):
        # WARNING : use iloc here, as loc doesn't take into account the sorting we did above
        standID = standRankingDfTemp.iloc[indexStand]["standID"]
        # We iterate to get ready for the next stand
        indexStand += 1
        if not standIsAlreadyHarvestedDict[standID]:
            # We get a maximum cut size
            maximumSizeToReach = MHS_CBAU.randomSelectCutSizeForPrescription(nonCommercialTreatment, dictForestCutSizesDistribution)
            
            # We propagate the cut; we don't avoid young stands here (as most non
            # commercial treatments are education treatments), but we restrict the propagation
            # to the stands identified in standRankingDfTemp before, which are suitable for
            # the prescription (right minimum and maximum age in particular)
            standsHarvestedEstimate = MHS_CBAU.standHarvestPropagationWithRestriction(standID,
                                                                                      maximumSizeToReach,
                                                                                      CELL_SIZE,
                                                                                      standNeighboursDict,
                                                                                      standCoordinatesDict,
                                                                                      standAgeDict,
                                                                                      standManagementUnitDict,
                                                                                      PROTECTED_AREAS_ID,
                                                                                      standIsAlreadyHarvestedDict,
                                                                                      avoidYoungStands = False,
                                                                                      optionalRestrictionList = standRankingDfTemp['standID'].values.tolist())
            
            # If harvesting this group of stands overshoots the target, we check another stand
            sumPixelsHarvest = 0
            for standHarvested in standsHarvestedEstimate:
                sumPixelsHarvest += len(standCoordinatesDict[standHarvested])
            if (counterAreaHarvested + (sumPixelsHarvest * cellsToHectare)) > areaTargetToReach * 1.05:
                continue
            
            ## HARVESTING STANDS
            
            else:
                # If planting, we make sure species are planted.
                if prescriptionParameters[nonCommercialTreatment]["Planting"] != "none":
                    plantingPrescriptionParameters, managementMap, numberOfPixelsHarvested = MHS_CBAU.PreparingPlantations(nonCommercialTreatment,
                                                                                                                           standsHarvestedEstimate,
                                                                                                                           prescriptionParameters,
                                                                                                                           plantingPrescriptionParameters,
                                                                                                                           managementMap,
                                                                                                                           standCompositionDict,
                                                                                                                           standCoordinatesDict,
                                                                                                                           COMMERCIAL_SPECIES_TO_PLANT)
                else:
                    # We indicate the pixels as harvested and add to the target
                    # No harvest propagation to nearby stands for non commercial treatments :
                    # we consider that these are more "ponctual" treatments
                    managementMap, numberOfPixelsHarvested = MHS_CBAU.harvestStands(managementMap,
                                                                                   standsHarvestedEstimate,
                                                                                   standCoordinatesDict,
                                                                                   prescriptionParameters[nonCommercialTreatment]["PrescriptionID"])
                
                ## FINISHING UP 
                
                # We update the surface harvested + indicate it as harvested
                counterAreaHarvested += numberOfPixelsHarvested * cellsToHectare
                standIsAlreadyHarvestedDict[standID] = True
        
    
    # We register the harvest into the counter
    
    # We stop when we have reached the surface target
        
    
    

#%% 6. CREATING OUTPUTS
# This is where we export the management map we have been making for the timestep,
# along with the edited/prepared Biomass Harvest parameter file to control Biomass
# Harvest for the current time step.
# We also export a file containing the repeated prescriptions for the next timestep.

# GIVE THE CHOICE OF WHERE THE PRESCRIPTION MAP AND TABLE ARE !! Not just in /tempMagicHarvest
# Also, make names more explicit for the maps and tables.

print("    MHS-CBAU : Creating outputs...")


# Create directory if it doesn't exist
os.makedirs(os.path.dirname(FOLDER_FOR_MAGICHARVEST_OUTPUTS), exist_ok=True)

# We save the pickle file with the data for the next repeated harvests
# We need to do it here to ensure one file per zone
if repeatPrescriptionsDict!= "noRepeatsForNow":
    MHS_CBAU.writeRepeatedPrescriptions(FOLDER_FOR_MAGICHARVEST_OUTPUTS, repeatPrescriptionsDict,
                                        timestep, timestepLength)
    
    
# Create harvest maps
# Before we do it, we remove all pixels corresponding to ecoregions = 0
MHS_CBAU.writeNewRasterDataInt16(managementMap,
                                 STANDS_MAP_PATH,
                                 FOLDER_FOR_MAGICHARVEST_OUTPUTS + "/prescriptions_MHS-CBAU_" + str(timestep) + ".tif")

# Create harvest txt file
# We add to the txt file :
# - The new plantation prescriptions
# - The surface to harvest for each prescription ID /fake management area

MHS_CBAU.writeHarvestParameterFile(managementMap,
                                   BIOMASS_HARVEST_PARAMETER_PREPARED_FILE_PATH,
                                   prescriptionParameters,
                                   plantingPrescriptionParameters,
                                   FOLDER_FOR_MAGICHARVEST_OUTPUTS + "/prescriptions_MHS-CBAU_" + str(timestep) + ".tif",
                                   timestep)



# Update table that gives the prescription names for each prescription ID
# for easy identification in GIS softwares of the harvest output maps
MHS_CBAU.WriteTableOfPrescriptionsID(FOLDER_FOR_MAGICHARVEST_OUTPUTS + "/prescriptionIDTable_" + str(timestep) + ".csv",
                                     prescriptionParameters,
                                     plantingPrescriptionParameters)

# We make a log of the harvested surfaces and volumes.
MHS_CBAU.writeMHSCBAU_Log(timestep,
                          timestepLength,
                          FOLDER_FOR_MAGICHARVEST_OUTPUTS + "/log_MHS-CBAU.csv",
                          managementMap,
                          volumeTargetCounterDict)
    
# Removing vegetation communities files if needed
if not DEBUG_MODE_ENABLED and DELETE_COMMUNITIES_FILES:
    if os.path.exists("./output-community-" + str(timestep- timestepLength) + ".img"):
        os.remove("./output-community-" + str(timestep- timestepLength) + ".img")
    if os.path.exists("./community-input-file-" + str(timestep- timestepLength) + ".csv"):
        os.remove("./community-input-file-" + str(timestep- timestepLength) + ".csv")
    if os.path.exists(("./community-input-file-" + str(timestep- timestepLength) + ".csv")[0:-3] + "txt"):
        os.remove(("./community-input-file-" + str(timestep- timestepLength) + ".csv")[0:-3] + "txt")

# We're done !